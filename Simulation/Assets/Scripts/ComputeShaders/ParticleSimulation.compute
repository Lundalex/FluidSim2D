#pragma kernel PreCalculations
#pragma kernel CalculateDensities
// #pragma kernel RbRbCollisions
// #pragma kernel RbParticleCollisions
#pragma kernel ParticleForces

#include "MathResources.hlsl"

static const int ThreadsNum = 32;

// Constants
const int ChunkNumW;
const int ChunkNumH;
const int IOOR;
const int Width;
const int Height;
const int ParticlesNum;
const int RBodiesNum;
const int MaxInfluenceRadius;
const int SpawnDims;
const int TimeStepsPerRender;
const int PStorageLength;

const float LookAheadFactor;
const float TargetDensity;
const float PressureMultiplier;
const float NearPressureMultiplier;
const float Damping;
const float Viscocity;
const float Gravity;
const float RBodyElasticity;
const float BorderPadding;
const float MaxInteractionRadius;
const float InteractionAttractionPower;
const float InteractionFountainPower;

// Per-timestep-set constants
const float DeltaTime;
const float MouseX;
const float MouseY;
const bool RMousePressed;
const bool LMousePressed;

// Particles - Buffers
RWStructuredBuffer<int2> SpatialLookup; // [ParticlesNum](particleIndex, ChunkKey)
RWStructuredBuffer<int> StartIndices;

RWStructuredBuffer<float2> PredPositions;
RWStructuredBuffer<float2> Positions;
RWStructuredBuffer<float2> Velocities;
RWStructuredBuffer<float2> LastVelocities;
RWStructuredBuffer<float> Densities;
RWStructuredBuffer<float> NearDensities;

bool ValidChunk(int ChunkX, int ChunkY)
{
    if (ChunkX >= 0 && ChunkX < ChunkNumW && ChunkY >= 0 && ChunkY < ChunkNumH) {return true;}
    return false;
}

float2 CalcDensity(int pIndex) // (density, nearDensity)
{
    // Int type conversion removes decimals, effectively doing a Floor() operation
    int ChunkX = (int)(PredPositions[pIndex].x / MaxInfluenceRadius);
    int ChunkY = (int)(PredPositions[pIndex].y / MaxInfluenceRadius);

    float totDensity = 0.0;
    float totNearDensity = 0.0;
    for (int x = -1; x <= 1; x++)
    {
        for (int y = -1; y <= 1; y++)
        {
            int CurChunkX = ChunkX + x;
            int CurChunkY = ChunkY + y;
            
            if (!ValidChunk(CurChunkX, CurChunkY)) {continue;}

            int ChunkKey = CurChunkY * ChunkNumW + CurChunkX;
            int startIndex = StartIndices[ChunkKey];

            int Index = startIndex;
            while (Index < ParticlesNum && ChunkKey == SpatialLookup[Index].y)
            {
                int otherPIndex = SpatialLookup[Index].x;

                float dst = length(PredPositions[pIndex] - PredPositions[otherPIndex]);

                totDensity += SmoothLiquid(dst, MaxInfluenceRadius);
                totNearDensity += SmoothLiquidNear(dst, MaxInfluenceRadius);

                // Increment Index each iteration - Chunk particle search algorithm
                Index += 1;
            }
        }
    }
    
    return float2(totDensity, totNearDensity);
}

float4 BoundraryCheck(float2 pos, float2 vel, float extraPadding)
{
    float totPadding = BorderPadding + extraPadding;
    float velFactor = 1 - Damping;

    if (pos.y > Height - totPadding)
    {
        vel.y = -abs(vel.y) * velFactor;
        pos.y = Height - totPadding;
    }
    else if (pos.y < totPadding)
    {
        vel.y = abs(vel.y) * velFactor;
        pos.y = totPadding;
    }
    if (pos.x > Width - totPadding)
    {
        vel.x = -abs(vel.x) * velFactor;
        pos.x = Width - totPadding;
    }
    else if (pos.x < totPadding)
    {
        vel.x = abs(vel.x) * velFactor;
        pos.x = totPadding;
    }
    
    return float4(pos.x, pos.y, vel.x, vel.y);
}

float DensityToPressure(float density)
{
    float densityError = density - TargetDensity;
    float pressure = densityError * PressureMultiplier;
    return pressure;
}

float SharedPressure(float densityA, float densityB)
{
    float pressureA = DensityToPressure(densityA);
    float pressureB = DensityToPressure(densityB);

    float sharedPressure = avg(pressureA, pressureB);

    return sharedPressure;
}

float SharedNearPressure(float nearDensityA, float nearDensityB)
{
    float nearPressureA = nearDensityA * NearPressureMultiplier;
    float nearPressureB = nearDensityB * NearPressureMultiplier;

    float sharedNearPressure = avg(nearPressureA, nearPressureB);

    return sharedNearPressure;
}

float2 PressureForce(int pIndex)
{
    // Int type conversion removes decimals, effectively doing a Floor() operation
    int ChunkX = (int)(PredPositions[pIndex].x / MaxInfluenceRadius);
    int ChunkY = (int)(PredPositions[pIndex].y / MaxInfluenceRadius);

    float2 totPressureForce = float2(0.0, 0.0);
    for (int x = -1; x <= 1; x++)
    {
        for (int y = -1; y <= 1; y++)
        {
            int CurChunkX = ChunkX + x;
            int CurChunkY = ChunkY + y;
            
            if (!ValidChunk(CurChunkX, CurChunkY)) {continue;}

            int ChunkKey = CurChunkY * ChunkNumW + CurChunkX;
            int startIndex = StartIndices[ChunkKey];

            int Index = startIndex; 
            while (Index < ParticlesNum && ChunkKey == SpatialLookup[Index].y)
            {
                int otherPIndex = SpatialLookup[Index].x;
                if (pIndex == otherPIndex) {Index += 1; continue;}

                float2 dst = PredPositions[pIndex] - PredPositions[otherPIndex];
                float absDst = length(dst);

                if (absDst >= MaxInfluenceRadius){Index += 1; continue;}
                float absPressureGradient = SmoothLiquidDer(absDst, MaxInfluenceRadius);
                float absNearPressureGradient = SmoothLiquidNearDer(absDst, MaxInfluenceRadius);

                float2 pressureGradient = float2(0.0, 0.0);
                float2 nearPressureGradient = float2(0.0, 0.0);

                if (absDst == 0) {
                    // semirandom direction
                    float2 randVector = float2(pIndex % 0.2842, pIndex % 0.1827);

                    pressureGradient = 0.05 * randVector * absPressureGradient;
                    nearPressureGradient = 0.05 * randVector * absNearPressureGradient;
                }
                else {
                    pressureGradient = normalize(dst) * absPressureGradient;
                    nearPressureGradient = normalize(dst) * absNearPressureGradient;
                }

                float densityA = Densities[pIndex];
                float densityB = Densities[otherPIndex];
                float avgPressure = SharedPressure(densityA, densityB);

                float nearDensityA = NearDensities[pIndex];
                float nearDensityB = NearDensities[otherPIndex];
                float avgNearPressure = SharedNearPressure(nearDensityA, nearDensityB);

                if (densityA + densityB == 0) {Index += 1; continue;}
                //                                                  + or - ????
                totPressureForce += (avgPressure * pressureGradient + avgNearPressure * nearPressureGradient) / avg(densityA, densityB);

                // Increment Index each iteration - Chunk particle search algorithm
                Index += 1;
            }
        }
    }

    return -totPressureForce;
}

float2 ViscocityForce(int pIndex)
{
    // Int type conversion removes decimals, effectively doing a Floor() operation
    int ChunkX = (int)(PredPositions[pIndex].x / MaxInfluenceRadius);
    int ChunkY = (int)(PredPositions[pIndex].y / MaxInfluenceRadius);

    float MaxInfluenceRadiusSqr = MaxInfluenceRadius * MaxInfluenceRadius;
    float2 totViscosityForce = float2(0.0, 0.0);
    for (int x = -1; x <= 1; x++)
    {
        for (int y = -1; y <= 1; y++)
        {
            int CurChunkX = ChunkX + x;
            int CurChunkY = ChunkY + y;
            
            if (!ValidChunk(CurChunkX, CurChunkY)) {continue;}

            int ChunkKey = CurChunkY * ChunkNumW + CurChunkX;
            int startIndex = StartIndices[ChunkKey];

            int Index = startIndex; 
            while (Index < ParticlesNum && ChunkKey == SpatialLookup[Index].y)
            {
                int otherPIndex = SpatialLookup[Index].x;
                if (pIndex == otherPIndex) {Index += 1; continue;}

                float2 dst = PredPositions[otherPIndex] - PredPositions[pIndex];
                float sqrDst = dot(dst, dst);

                if (sqrDst > MaxInfluenceRadiusSqr) {Index += 1; continue;}

                float absDst = sqrt(sqrDst);
                totViscosityForce += (LastVelocities[otherPIndex] - LastVelocities[pIndex]) * SmoothViscosityLaplacian(absDst, MaxInfluenceRadius);

                // Increment Index each iteration - Chunk particle search algorithm
                Index += 1;
            }
        }
    }

    return totViscosityForce * Viscocity;
}

float2 InteractionForce(int pIndex)
{
    if (!LMousePressed && !RMousePressed) {return float2(0.0, 0.0);}
    int dir = 0;
    if (LMousePressed) {dir = -1;}
    else if (RMousePressed) {dir = 1;}

    float2 dst = PredPositions[pIndex] - float2(MouseX, MouseY);

    float absDst = length(dst);

    if (absDst > MaxInteractionRadius) {return float2(0.0, 0.0);}

    float absInteractionGradient = SmoothLiquid(absDst, MaxInteractionRadius);

    if (absDst == 0) {return float2(0.0, 0.0);}

    float2 interactionGradient = normalize(dst) * absInteractionGradient;

    float2 baseInteractionForce = interactionGradient * InteractionAttractionPower * dir;
    float fountainInteractionForce = 0;
    if (dir == -1)
    {
        float dstX = MaxInteractionRadius - abs(dst.x);
        fountainInteractionForce = InteractionFountainPower * absInteractionGradient * dstX;
    }

    return baseInteractionForce + float2(0.0, fountainInteractionForce);
}

[numthreads(ThreadsNum,1,1)]
void PreCalculations (uint3 id : SV_DispatchThreadID)
{
    int i = id.x;

    PredPositions[i] = Positions[i] + Velocities[i] * LookAheadFactor;
    // Make sure PredPositions[i] is within the world boundrary
    PredPositions[i].x = max(min(PredPositions[i].x, Width - 0.1), 0.1);
    PredPositions[i].y = max(min(PredPositions[i].y, Height - 0.1), 0.1);

    // LastVelocities
    LastVelocities[i] = Velocities[i];
}

[numthreads(ThreadsNum,1,1)]
void CalculateDensities (uint3 id : SV_DispatchThreadID)
{
    int i = id.x;
    // Density
    float2 Dns = CalcDensity(i);
    Densities[i] = Dns.x;
    NearDensities[i] = Dns.y;
}

[numthreads(ThreadsNum,1,1)]
void ParticleForces (uint3 id : SV_DispatchThreadID)
{
    int i = id.x;

    Velocities[i].y -= Gravity * DeltaTime;
 
    float2 presureForce = PressureForce(i);
    float2 interactionForce = InteractionForce(i);
    float2 viscocityForce = ViscocityForce(i);
    //                                                                   / (constant) or density[i]???
    float2 totForce = (presureForce + viscocityForce + interactionForce) / 9;

    Velocities[i] += totForce * DeltaTime;
    Positions[i] += Velocities[i] * DeltaTime;

    float4 PosVelData = BoundraryCheck(Positions[i], Velocities[i], 0);
    Positions[i] = float2(PosVelData.x, PosVelData.y);
    Velocities[i] = float2(PosVelData.z, PosVelData.w);
}