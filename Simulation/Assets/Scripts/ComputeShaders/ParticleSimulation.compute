#pragma kernel PreCalculations
#pragma kernel CalculateDensities
#pragma kernel ParticleForces
#pragma kernel UpdatePositions
#pragma kernel ConsumeStickynessRequests

#include "MathResources.hlsl"

static const int ThreadsNum = 512;

// Constants
const int ChunkNumW;
const int ChunkNumH;
const int ChunkNum;
const int IOOR;
const int Width;
const int Height;
const int ParticlesNum;
const int RBodiesNum;
const int MaxInfluenceRadius;
const int MaxInfluenceRadiusSqr;
const float InvMaxInfluenceRadius;
const int SpawnDims;
const int TimeStepsPerRender;

const float LookAheadFactor;
const float RBodyElasticity;
const float BorderPadding;
const float MaxInteractionRadius;
const float InteractionAttractionPower;
const float InteractionFountainPower;
const int SpringSafety;
const int SpringPairsLen;
const float Plasticity;

// Per-timestep-set constants
const float DeltaTime;
const float SRDeltaTime;

const int CurTimeStepInt; // range(1 - 100), changes every time step
const int LastTimeStepInt; // CurTimeStepInt value from last time step

const float MouseX;
const float MouseY;
const bool RMousePressed;
const bool LMousePressed;

// Particles - Buffers
RWStructuredBuffer<int2> SpatialLookup; // [ParticlesNum](particleIndex, ChunkKey)
RWStructuredBuffer<int> StartIndices;
RWStructuredBuffer<int> ChunkSizes;

struct SpringStruct
{
    int linkedIndex;
    float restLength;
    // float yieldLen;
    // float plasticity;
    // float stiffness;
};
const bool FrameBufferCycle;
RWStructuredBuffer<int> SpringCapacities;
RWStructuredBuffer<int> SpringStartIndices_dbA; // Result A
RWStructuredBuffer<int> SpringStartIndices_dbB; // Result B

struct PTypeStruct
{
    float TargetDensity;
    int MaxInfluenceRadius;
    float Pressure;
    float NearPressure;
    float Damping;
    float Viscocity;
    float Elasticity;
    float Plasticity;
    float Stickyness;
    float Gravity;
    float colorG;
};
RWStructuredBuffer<PTypeStruct> PTypes;

struct PDataStruct
{
    float2 PredPosition;
    float2 Position;
    float2 Velocity;
    float2 LastVelocity;
    float Density;
    float NearDensity;
    int POrder;
    int Last_POrder_ChunkKey; // int2 Get_POrder_ChunkKey(Last_POrder_ChunkKey) -> (POrder, ChunkKey)
    int PType;
};
RWStructuredBuffer<PDataStruct> PData;

struct StickynessRequestStruct
{
    int pIndex;
    int StickyLineIndex;
    float2 StickyLineDst;
    float absDstToLineSqr;
    float RBStickyness;
    float RBStickynessRange;
};
RWStructuredBuffer<StickynessRequestStruct> SortedStickyRequests;

bool ValidChunk(int ChunkX, int ChunkY)
{
    if (ChunkX >= 0 && ChunkX < ChunkNumW && ChunkY >= 0 && ChunkY < ChunkNumH) {return true;}
    return false;
}

bool IsInfluencedChunk(int x, int y, int localPosX, int localPosY)
{
    if (x != 0 && y != 0)
    {
        int xUse = 0;
        int yUse = 0;
        if (x == 1 && y == 1) { xUse = 1; yUse = 1; }
        else if (x == -1 && y == -1) { xUse = 0; yUse = 0; }
        else if (x == 1 && y == -1) { xUse = 1; yUse = 0; }
        else if (x == -1 && y == 1) { xUse = 0; yUse = 1; }
        float2 dst = float2(localPosX - xUse, localPosY - yUse);
        float absDstSqr = dot(dst, dst);
        if (absDstSqr > MaxInfluenceRadiusSqr) { return false; }
    }
    return true;
}
int2 Get_POrder_ChunkKey(int POrder_ChunkKey)
{
    int pOrder = (int)(POrder_ChunkKey / ChunkNum);
    int chunkKey = POrder_ChunkKey % ChunkNum;
    return int2(pOrder, chunkKey);
}

float2 CalcDensityAndTransferSpringData(int pIndex) // (density, nearDensity)
{
    PDataStruct PData_i = PData[pIndex];
    // Int type conversion removes decimals, effectively doing a Floor() operation


    // // Get LastChunkKey
    // int2 last_POrder_ChunkKey = Get_POrder_ChunkKey(PData_i.Last_POrder_ChunkKey);
    // int lastPOrder = last_POrder_ChunkKey.x;
    // int lastChunkKey = last_POrder_ChunkKey.y;
    // // Set new LastChunkKey
    int chunkX = (int)(PData_i.Position.x * InvMaxInfluenceRadius);
    int chunkY = (int)(PData_i.Position.y * InvMaxInfluenceRadius);
    // int chunkKey = chunkY * ChunkNumW + chunkX;
    // PData[pIndex].Last_POrder_ChunkKey = chunkKey + ChunkNum * PData_i.POrder;


    float totDensity = 0.0;
    float totNearDensity = 0.0;
    for (int x = -1; x <= 1; x++)
    {
        for (int y = -1; y <= 1; y++)
        {
            int curChunkX = chunkX + x;
            int curChunkY = chunkY + y;

            if (!ValidChunk(curChunkX, curChunkY)) {continue;}

            int chunkKey = curChunkY * ChunkNumW + curChunkX;
            int startIndex = StartIndices[chunkKey];

            int Index = startIndex;
            int neighboorCount = 0;
            while (Index < ParticlesNum && chunkKey == SpatialLookup[Index].y)
            {
                int otherPIndex = SpatialLookup[Index].x;
                PDataStruct PData_otherPIndex = PData[otherPIndex];

                // -- Spring handling --

                int otherChunkX = (int)(PData_otherPIndex.Position.x * InvMaxInfluenceRadius);
                int otherChunkY = (int)(PData_otherPIndex.Position.y * InvMaxInfluenceRadius);
                int otherChunkKey = otherChunkY * ChunkNumW + otherChunkX;

                int lastSpringIndex = 0;
                for (int i = 0; i < 9; i++)
                {
                    if ()
                    {

                    }
                    // lastSpringIndex += 
                }


                // // Get springsNum up until and excluding current chunk + Unique springIndex in chunk
                // int lastNeighboorCount = getLastNeighboorCount();
                // int LastSpringIndex = FrameBufferCycle
                // ? SpringStartIndices_dbB[lastChunkKey-1] + lastPOrder * SpringCapacities[lastChunkKey-1] + lastNeighboorCount
                // : SpringStartIndices_dbA[lastChunkKey-1] + lastPOrder * SpringCapacities[lastChunkKey-1] + lastNeighboorCount;
                // // Update PData pOrder for NewSpringIndex 
                // if (pIndex == otherPIndex) { int pOrder = Index - startIndex; PData[pIndex].POrder = pOrder; PData_i.POrder = pOrder; }
                // int NewSpringIndex = FrameBufferCycle
                // ? SpringStartIndices_dbA[chunkKey-1] + PData_i.POrder * SpringCapacities[chunkKey-1] + neighboorCount
                // : SpringStartIndices_dbB[chunkKey-1] + PData_i.POrder * SpringCapacities[chunkKey-1] + neighboorCount;


                // -- Calculate densities --

                float dst = length(PData_i.PredPosition - PData[otherPIndex].PredPosition);
                totDensity += SmoothLiquid(dst, MaxInfluenceRadius);
                totNearDensity += SmoothLiquidNear(dst, MaxInfluenceRadius);

                // -- Increment Index each iteration - Chunk particle search algorithm --

                neighboorCount += 1;
                Index += 1;
            }
        }
    }
    
    return float2(totDensity, totNearDensity);
}

float4 BoundraryCheck(float2 pos, float2 vel, float extraPadding, float Damping)
{
    float totPadding = BorderPadding + extraPadding;
    float velFactor = 1 - Damping;

    if (pos.y > Height - totPadding)
    {
        vel.y = -abs(vel.y) * velFactor;
        pos.y = Height - totPadding;
    }
    else if (pos.y < totPadding)
    {
        vel.y = abs(vel.y) * velFactor;
        pos.y = totPadding;
    }
    if (pos.x > Width - totPadding)
    {
        vel.x = -abs(vel.x) * velFactor;
        pos.x = Width - totPadding;
    }
    else if (pos.x < totPadding)
    {
        vel.x = abs(vel.x) * velFactor;
        pos.x = totPadding;
    }
    
    return float4(pos.x, pos.y, vel.x, vel.y);
}

float DensityToPressure(float density, float TargetDensity, float Pressure)
{
    float densityError = density - TargetDensity;
    float pressure = densityError * Pressure;
    return pressure;
}

float SharedPressure(float densityA, float densityB, float TargetDensityA, float TargetDensityB, float PressureA, float PressureB)
{
    float pressureA = DensityToPressure(densityA, TargetDensityA, PressureA);
    float pressureB = DensityToPressure(densityB, TargetDensityB, PressureB);
    float sharedPressure = avg(pressureA, pressureB);

    return sharedPressure;
}

float SharedNearPressure(float nearDensityA, float nearDensityB, float NearPressureMultiplierA, float NearPressureMultiplierB)
{
    float nearPressureA = nearDensityA * NearPressureMultiplierA;
    float nearPressureB = nearDensityB * NearPressureMultiplierB;
    float sharedNearPressure = avg(nearPressureA, nearPressureB);

    return sharedNearPressure;
}

float2 PressureForce(float densityA, float densityB, float nearDensityA, float nearDensityB, PTypeStruct PType_i, PTypeStruct PType_otherPIndex, float absDst, float2 normDst, int randSeed)
{
    float absPressureGradient = SmoothLiquidDer(absDst, MaxInfluenceRadius);
    float absNearPressureGradient = SmoothLiquidNearDer(absDst, MaxInfluenceRadius);

    float2 pressureGradient = float2(0.0, 0.0);
    float2 nearPressureGradient = float2(0.0, 0.0);

    if (absDst == 0) {
        // semirandom direction, not normalized
        float2 randVector = float2(randSeed % 0.2842, randSeed % 0.1827);

        pressureGradient = 0.05 * randVector * absPressureGradient;
        nearPressureGradient = 0.05 * randVector * absNearPressureGradient;
    }
    else {
        pressureGradient = normDst * absPressureGradient;
        nearPressureGradient = normDst * absNearPressureGradient;
    }

    float avgPressure = SharedPressure(densityA, densityB, PType_i.TargetDensity, PType_otherPIndex.TargetDensity, PType_i.Pressure, PType_otherPIndex.Pressure);

    float avgNearPressure = SharedNearPressure(nearDensityA, nearDensityB, PType_i.NearPressure, PType_otherPIndex.NearPressure);

    if (densityA + densityB == 0) {return float2(0.0, 0.0);}
    float2 pressureForce = (avgPressure * pressureGradient + avgNearPressure * nearPressureGradient) / avg(densityA, densityB);

    return pressureForce;
}

float2 ViscocityForce(float2 LastVelocityA, float2 LastVelocityB, PTypeStruct PType_i, PTypeStruct PType_otherPIndex, float absDst)
{
    float2 viscocityForce = (LastVelocityB - LastVelocityA) * SmoothViscosityLaplacian(absDst, MaxInfluenceRadius);

    return viscocityForce * avg(PType_i.Viscocity, PType_otherPIndex.Viscocity);
}

float2 StickynessForce(PDataStruct PData_i, PTypeStruct PType_i, StickynessRequestStruct stickynessRequest)
{
    float absDstToLine = sqrt(stickynessRequest.absDstToLineSqr);

    float Stickyness = stickynessRequest.RBStickyness * PType_i.Stickyness;
    float absStickynessForce = RBPStickynessModel(Stickyness, absDstToLine, stickynessRequest.RBStickynessRange);

    // If the lenSqr of a vector is 0, normalized(0) does a /0 operation, leading to thread errors
    // Over time, this decreases the amount of available threads, leading to decreased performance!
    if (dot(stickynessRequest.StickyLineDst, stickynessRequest.StickyLineDst) == 0) { return float2(0, 0); }

    float2 normDstToLine = normalize(stickynessRequest.StickyLineDst);
    float2 stickynessForce = absStickynessForce * normDstToLine;
    
    return stickynessForce;
}

float2 LiquidSpringForce(PTypeStruct PType_i, PTypeStruct PType_otherPIndex, int pIndex, int otherPIndex, float absDst, float2 normDst)
{
    return float2(0.0, 0.0);
    // if (absDst > MaxInfluenceRadius) { return float2(0.0, 0.0); }

    // // SpringPairsBuffer == true -> using doublebuffer A
    // // SpringPairsBuffer == false -> using doublebuffer B
    // bool SpringPairsBuffer = true;
    // int2 springKeys = GetSpringKeys(pIndex, otherPIndex);

    // SpringStruct lastSpring;
    // if (true) { lastSpring = SpringPairsA[springKeys.x]; }
    // else { lastSpring = SpringPairsB[springKeys.x]; }

    // // If no spring exists, create a new one
    // if (lastSpring.linkedIndex != otherPIndex)
    // {
    //     lastSpring.linkedIndex = otherPIndex;
    //     lastSpring.restLength = MaxInfluenceRadius / 2;
    // }

    // // // Plasticity calculations
    // // float diffMng = absDst - lastSpring.restLength;
    // // float absDiffMng = abs(diffMng);
    // // int sgnDiffMng = sign(diffMng);
    // // float plasticityConst = 0.01;
    // // float tolDeformation = 0.1; // = yieldRatio / restLength
    // // // ∆L = ∆t * α * sign(r − L) * max(0,|r −L| − γL)
    // // lastSpring.restLength -= LiquidSpringPlasticityModel(plasticityConst, sgnDiffMng, absDiffMng, tolDeformation, DeltaTime);

    // // Elasticity calculations
    // float springStiffness = Plasticity;
    // float absSpringForce = LiquidSpringForceModel(springStiffness, lastSpring.restLength, MaxInfluenceRadius, absDst);
    // float2 springForce = absSpringForce * normDst * 0.5;

    // // "Transfer" modified spring to new springPairs index
    // if (true) { SpringPairsB[springKeys.y] = lastSpring; }
    // else { SpringPairsA[springKeys.y] = lastSpring; }

    // return -springForce;
}

float2 InteractionForce(int pIndex)
{
    if (!LMousePressed && !RMousePressed) {return float2(0.0, 0.0);}
    int dir = 0;
    if (LMousePressed) {dir = -1;}
    else if (RMousePressed) {dir = 1;}

    float2 dst = PData[pIndex].PredPosition - float2(MouseX, MouseY);

    float absDst = length(dst);

    if (absDst > MaxInteractionRadius) {return float2(0.0, 0.0);}

    float absInteractionGradient = SmoothLiquid(absDst, MaxInteractionRadius);

    if (absDst == 0) {return float2(0.0, 0.0);}

    float2 interactionGradient = normalize(dst) * absInteractionGradient;

    float2 baseInteractionForce = interactionGradient * InteractionAttractionPower * dir;
    float fountainInteractionForce = 0;
    if (dir == -1)
    {
        float dstX = MaxInteractionRadius - abs(dst.x);
        fountainInteractionForce = InteractionFountainPower * absInteractionGradient * dstX;
    }

    return baseInteractionForce + float2(0.0, fountainInteractionForce);
}

[numthreads(ThreadsNum,1,1)]
void PreCalculations (uint3 id : SV_DispatchThreadID)
{
    int i = id.x;

    PData[i].PredPosition = PData[i].Position + PData[i].Velocity * LookAheadFactor;
    // Make sure PredPositions[i] is within the world boundrary
    PData[i].PredPosition.x = max(min(PData[i].PredPosition.x, Width - 0.1), 0.1);
    PData[i].PredPosition.y = max(min(PData[i].PredPosition.y, Height - 0.1), 0.1);

    // LastVelocities
    PData[i].LastVelocity = PData[i].Velocity;
}

[numthreads(ThreadsNum,1,1)]
void CalculateDensities (uint3 id : SV_DispatchThreadID)
{
    int i = id.x;
    // density
    float2 Dns = CalcDensityAndTransferSpringData(i);
    PData[i].Density = Dns.x;
    PData[i].NearDensity = Dns.y;
}

[numthreads(ThreadsNum,1,1)]
void ParticleForces (uint3 id : SV_DispatchThreadID)
{
    int i = id.x;

    // Can probably be optimised by using if (i > otherPIndex) to avoid calculating each pair twice

    // Int type conversion removes decimals, effectively doing a Floor() operation
    PDataStruct PData_i = PData[i];
    PTypeStruct PType_i = PTypes[PData_i.PType];
    int chunkX = (int)(PData_i.Position.x * InvMaxInfluenceRadius);
    int chunkY = (int)(PData_i.Position.y * InvMaxInfluenceRadius);

    int LastPOrder = PData_i.Last_POrder_ChunkKey % ChunkNum;
    int LastChunkKey = (int)(PData_i.Last_POrder_ChunkKey / ChunkNum);

    // float localPosX = (PData_i.PredPosition.x % MaxInfluenceRadius) * InvMaxInfluenceRadius;
    // float localPosY = (PData_i.PredPosition.y % MaxInfluenceRadius) * InvMaxInfluenceRadius;
    float2 totPressureForce = float2(0.0, 0.0);
    float2 totViscocityForce = float2(0.0, 0.0);
    float2 totSpringForce = float2(0.0, 0.0);
    int neighboorCount = 0;
    for (int x = -1; x <= 1; x++)
    {
        for (int y = -1; y <= 1; y++)
        {
            int curChunkX = chunkX + x;
            int curChunkY = chunkY + y;

            if (!ValidChunk(curChunkX, curChunkY)) { continue; }

            int chunkKey = curChunkY * ChunkNumW + curChunkX;
            int startIndex = StartIndices[chunkKey];

            int Index = startIndex; 
            while (Index < ParticlesNum && chunkKey == SpatialLookup[Index].y)
            {
                int otherPIndex = SpatialLookup[Index].x;
                if (i == otherPIndex) { Index += 1; neighboorCount += 1; continue; }
                PDataStruct PData_otherPIndex = PData[otherPIndex];
                PTypeStruct PType_otherPIndex = PTypes[PData_otherPIndex.PType];

                float2 dst = PData_otherPIndex.PredPosition - PData_i.PredPosition;
                float sqrDst = dot(dst, dst);

                if (sqrDst > MaxInfluenceRadiusSqr) { Index += 1; neighboorCount += 1; continue; }
                float absDst = sqrt(sqrDst);
                float2 normDst = normalize(dst);
                
                totPressureForce += PressureForce(PData_i.Density, PData_otherPIndex.Density, PData_i.NearDensity, PData_otherPIndex.NearDensity, PType_i, PType_otherPIndex, absDst, normDst, otherPIndex);
                totViscocityForce += ViscocityForce(PData_i.LastVelocity, PData_otherPIndex.LastVelocity, PType_i, PType_otherPIndex, absDst); 
                // totSpringForce += LiquidSpringForce(PType_i, PType_otherPIndex, i, otherPIndex, absDst, normDst);

                // -- Springs --


                // // Get springsNum up until and excluding current chunk + unique springIndex in chunk
                // int springIndex = FrameBufferCycle
                // ? SpringStartIndices_dbA[chunkKey-1] + PData_i.POrder * SpringCapacities[chunkKey-1] + neighboorCount
                // : SpringStartIndices_dbB[chunkKey-1] + PData_i.POrder * SpringCapacities[chunkKey-1] + neighboorCount;


                // Increment Index each iteration - particle chunks algorithm, particle springs algorithm
                Index += 1;
                neighboorCount += 1;
            }
        }
    }

    float2 interactionForce = InteractionForce(i);

    float2 totForce = totPressureForce + totViscocityForce + totSpringForce + interactionForce + float2(0, -PType_i.Gravity);
    PData[i].Velocity += totForce * DeltaTime;
}

[numthreads(ThreadsNum,1,1)]
void UpdatePositions (uint3 id : SV_DispatchThreadID)
{
    int i = id.x;

    PDataStruct PData_i = PData[i];

    PData_i.Position += PData_i.Velocity * DeltaTime;

    float4 PosVelData = BoundraryCheck(PData_i.Position, PData_i.Velocity, 0, PTypes[PData_i.PType].Damping);
    PData[i].Position = float2(PosVelData.x, PosVelData.y);
    PData[i].Velocity = float2(PosVelData.z, PosVelData.w);
}

[numthreads(ThreadsNum,1,1)]
void ConsumeStickynessRequests (uint3 id : SV_DispatchThreadID)
{
    int i = id.x;

    StickynessRequestStruct stickynessRequest = SortedStickyRequests[i];
    int pIndex = stickynessRequest.pIndex;

    // This does many "unnecessary" iterations for every id.x, but since thread management complexity is reduced, performance is higher
    float smallestDstSqr = 100;
    for (int offset = -3; offset <= 3; offset++) {
        if (offset == 0) continue;

        int idx = i + offset;
        if (idx > 0 && idx < 4098) {
            if (SortedStickyRequests[idx].pIndex == pIndex) {
                if (SortedStickyRequests[idx].absDstToLineSqr < smallestDstSqr) {
                    smallestDstSqr = SortedStickyRequests[idx].absDstToLineSqr;
                }
            }
        }
    }

    if (stickynessRequest.absDstToLineSqr <= smallestDstSqr) {
        PDataStruct PData_i = PData[pIndex];
        PTypeStruct PType_i = PTypes[PData_i.PType];
        float2 stickynessForce = StickynessForce(PData_i, PType_i, stickynessRequest);
    
        PData[pIndex].Velocity += stickynessForce * DeltaTime;  
    }
}