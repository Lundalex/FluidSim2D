#pragma kernel RenderParticles;

#include "MathResources.hlsl"

static const int ThreadsNum = 32;

const float VisualParticleRadii;
const float RBRenderThickness;
const int RBVectorNum;
const int ResolutionX;
const int ResolutionY;

const int Width;
const int Height;
const int MaxInfluenceRadius;
const int ChunkNumW;
const int ChunkNumH;
const int ParticlesNum;

const int RBodiesNum;

RWTexture2D<float4> Result;

// RWStructuredBuffer<float2> RBPositions;
// RWStructuredBuffer<float2> RBVelocities;
// RWStructuredBuffer<float2> RBProperties;

RWStructuredBuffer<int2> SpatialLookup;
RWStructuredBuffer<int> StartIndices;

struct PTypeStruct
{
    float TargetDensity;
    int MaxInfluenceRadius;
    float Pressure;
    float NearPressure;
    float Damping;
    float Viscocity;
    float Elasticity;
    float Plasticity;
    float Gravity;
    float colorG;
};
RWStructuredBuffer<PTypeStruct> PTypes;

struct PDataStruct
{
    float2 PredPosition;
    float2 Position;
    float2 Velocity;
    float2 LastVelocity;
    float Density;
    float NearDensity;
    int PType;
};
RWStructuredBuffer<PDataStruct> PData;

struct RBDataStruct
{
    float2 Position;
    float2 Velocity;
    int2 LineIndices;
};
RWStructuredBuffer<RBDataStruct> RBData;

struct RBVectorStruct
{
    float2 Position;
    int ParentRBIndex;
};
RWStructuredBuffer<RBVectorStruct> RBVector;

bool ValidChunk(int ChunkX, int ChunkY)
{
    if (ChunkX >= 0 && ChunkX < ChunkNumW && ChunkY >= 0 && ChunkY < ChunkNumH) {return true;}
    return false;
}

float2 SignedDistanceToLineSegment(float2 A, float2 B, float2 P)
{
    float2 AB = B - A;
    float2 AP = P - A;
    float ABLengthSquared = dot(AB, AB);

    // Scalar projection
    float AP_dot_AB = dot(AP, AB);
    float t = AP_dot_AB / ABLengthSquared;

    // Clamp t to the closest point on the line segment
    t = clamp(t, 0.0, 1.0);

    // Closest point on line segment to P
    float2 closestPoint = A + t * AB;

    // Return the distance vector from P to the closest point
    return P - closestPoint;
}

[numthreads(ThreadsNum,ThreadsNum,1)]
void RenderParticles (uint3 id : SV_DispatchThreadID)
{
    // texturePosition has float x, y values between 0 and 1
    float pixelPosX = (float)id.x * (float)Width / (float)ResolutionX;
    float pixelPosY = (float)id.y * (float)Height / (float)ResolutionY;
    float2 pixelPos = float2(pixelPosX, pixelPosY);

    // Int type conversion removes decimals, effectively doing a Floor() operation
    int ChunkX = (int)((float)pixelPos.x / (float)MaxInfluenceRadius);
    int ChunkY = (int)((float)pixelPos.y / (float)MaxInfluenceRadius);

    for (int x = -1; x <= 1; x++)
    {
        for (int y = -1; y <= 1; y++)
        {
            int CurChunkX = ChunkX + x;
            int CurChunkY = ChunkY + y;
            
            if (!ValidChunk(CurChunkX, CurChunkY)) {continue;}

            int ChunkKey = CurChunkY * ChunkNumW + CurChunkX;
            int startIndex = StartIndices[ChunkKey];

            int Index = startIndex; 
            while (Index < ParticlesNum && ChunkKey == SpatialLookup[Index].y)
            {
                int otherPIndex = SpatialLookup[Index].x;

                float dst = length(pixelPos - PData[otherPIndex].Position);

                if (dst < VisualParticleRadii)
                {
                    float r = min(1.0, length(PData[otherPIndex].Velocity)/10);
                    float g = PTypes[PData[otherPIndex].PType].colorG;
                    float b = max(0.0, 1 - length(PData[otherPIndex].Velocity)/10);
                    Result[id.xy] = float4(r, g, b, 0.0);
                    return;
                }

                // Increment Index each iteration - Chunk particle search algorithm
                Index += 1;
            }
        }
    }

    for (int LineIndex = 0; LineIndex < RBVectorNum-1; LineIndex++)
    {
        RBVectorStruct lineVectorA = RBVector[LineIndex];
        RBVectorStruct lineVectorB = RBVector[LineIndex+1];

        if (lineVectorA.ParentRBIndex != lineVectorB.ParentRBIndex) {continue;}

        RBDataStruct parentRBData = RBData[lineVectorA.ParentRBIndex]; // A and B have the same parent
        float2 dstToLine = SignedDistanceToLineSegment(lineVectorA.Position + parentRBData.Position, lineVectorB.Position + parentRBData.Position, pixelPos);

        if (length(dstToLine) < RBRenderThickness)
        {
            // RbVelocities not in use currently
            // float r = min(1.0, length(RBVelocities[i])/10);
            // float b = max(0.0, 1 - length(RBVelocities[i])/10);
            Result[id.xy] = float4(1, 1, 1, 0.0);
            return;
        }
    }

    // for (int i = 0; i < RBodiesNum; i++)
    // {
    //     float dst = length(pixelPos - RBPositions[i]);
    //     if (dst < RBProperties[i].x)
    //     {
    //         // RbVelocities not in use currently
    //         // float r = min(1.0, length(RBVelocities[i])/10);
    //         // float b = max(0.0, 1 - length(RBVelocities[i])/10);
    //         Result[id.xy] = float4(1, 1, 1, 0.0);
    //         return;
    //     }
    // }

    Result[id.xy] = float4(0.0, 0.0, 0.0, 0.0);
}