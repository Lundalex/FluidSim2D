#pragma kernel Render;

#include "MathResources.hlsl"
#include "CompositionResources.hlsl"

static const int ThreadsNum = 32;

const float VisualParticleRadii;
const float RBRenderThickness;
const int RBVectorNum;
const int ResolutionX;
const int ResolutionY;

const int Width;
const int Height;
const int MaxInfluenceRadius;
const int ChunkNumW;
const int ChunkNumH;
const int ParticlesNum;
const int RBodiesNum;

RWTexture2D<float4> Result;

RWStructuredBuffer<int2> SpatialLookup;
RWStructuredBuffer<int> StartIndices;

struct PTypeStruct
{
    float TargetDensity;
    int MaxInfluenceRadius;
    float Pressure;
    float NearPressure;
    float Damping;
    float Viscocity;
    float Elasticity;
    float Plasticity;
    float Stickyness;
    float Gravity;
    float colorG;
};
RWStructuredBuffer<PTypeStruct> PTypes;

struct PDataStruct
{
    float2 PredPosition;
    float2 Position;
    float2 Velocity;
    float2 LastVelocity;
    float Density;
    float NearDensity;
    int LastChunkKey_PType_POrder; // flat 3 int structure
    // POrder; // POrder is dynamic, 
    // LastChunkKey; // 0 <= LastChunkKey <= ChunkNum
    // PType; // 0 <= PType <= PTypeNum
};
RWStructuredBuffer<PDataStruct> PData;

struct RBDataStruct
{
    float2 Position;
    float2 Velocity;
    // radians / second
    float AngularImpulse;
    float Stickyness;
    float StickynessRange;
    float StickynessRangeSqr;
    float2 NextPos;
    float2 NextVel;
    float NextAngImpulse;
    float Mass;
    int2 LineIndices;
    float MaxDstSqr;
    int WallCollision;
    int Stationary; // 1 -> Stationary, 0 -> Non-stationary
};
RWStructuredBuffer<RBDataStruct> RBData;

struct RBVectorStruct
{
    float2 Position;
    float2 LocalPosition;
    float3 ParentImpulse;
    int ParentRBIndex;
    int WallCollision;
};
RWStructuredBuffer<RBVectorStruct> RBVector;

bool ValidChunk(int ChunkX, int ChunkY)
{
    return ChunkX >= 0 && ChunkX < ChunkNumW && ChunkY >= 0 && ChunkY < ChunkNumH;
}


[numthreads(ThreadsNum,ThreadsNum,1)]
void Render (uint3 id : SV_DispatchThreadID)
{
    float pixelPosX = (float)id.x * (float)Width / (float)ResolutionX;
    float pixelPosY = (float)id.y * (float)Height / (float)ResolutionY;
    float2 pixelPos = float2(pixelPosX, pixelPosY);
    int ChunkX = (int)((float)pixelPos.x / (float)MaxInfluenceRadius);
    int ChunkY = (int)((float)pixelPos.y / (float)MaxInfluenceRadius);

    // Render rigid bodies
    int rayHits = 0;
    float rayY = pixelPos.y;
    float2 rayCoordA = float2(0, rayY);
    float2 rayCoordB = float2(Width, rayY);
    for (int RBIndex = 0; RBIndex < RBodiesNum; RBIndex++)
    {
        RBDataStruct RBData_i = RBData[RBIndex];
        float2 dst = pixelPos - RBData_i.Position;
        float dstSqr = dot(dst, dst);
        if (dstSqr > RBData_i.MaxDstSqr) { continue; }

        float2 localRayCoordA = rayCoordA - RBData_i.Position;
        float2 localRayCoordB = rayCoordB - RBData_i.Position;
        float localRayPosX = pixelPos.x - RBData_i.Position.x;
        int startIndex = RBData_i.LineIndices.x;
        int endIndex = RBData_i.LineIndices.y;
        for (int lineIndex = startIndex; lineIndex < endIndex; lineIndex++)
        {
            float2 localVecA = RBVector[lineIndex].Position;
            float2 localVecB = RBVector[lineIndex+1].Position;
            if (CheckLinesIntersect(localVecA, localVecB, localRayCoordA, localRayCoordB))
            { 
                if (LineIntersectionPoint(localVecA, localVecB, localRayCoordA, localRayCoordB).x < localRayPosX)
                {
                    rayHits++; 
                }
            }
        }
        if ((uint)rayHits % 2 == 1) { Result[id.xy] = float4(1, 1, 1, 0.0); return; }
    }

    // Render particle liquids
    float minDst = VisualParticleRadii;
    bool particleFound;
    for (int x = -1; x <= 1; x++)
    {
        for (int y = -1; y <= 1; y++)
        {
            int CurChunkX = ChunkX + x;
            int CurChunkY = ChunkY + y;

            if (!ValidChunk(CurChunkX, CurChunkY)) {continue;}

            int ChunkKey = CurChunkY * ChunkNumW + CurChunkX;
            int startIndex = StartIndices[ChunkKey];

            int Index = startIndex; 
            while (Index < ParticlesNum && ChunkKey == SpatialLookup[Index].y)
            {
                int pIndex = SpatialLookup[Index].x;

                float dst = length(pixelPos - PData[pIndex].Position);

                if (dst < minDst)
                {
                    float r = min(1.0, length(PData[pIndex].Velocity)/10);
                    float g = PTypes[PData[pIndex].PType].colorG;
                    float b = max(0.0, 1 - length(PData[pIndex].Velocity)/10);
                    Result[id.xy] = float4(r, g, b, 0.0);
                    minDst = dst;
                    particleFound = true;
                }

                // Increment Index each iteration - Chunk particle search algorithm
                Index += 1;
            }
        }
    }
    if (particleFound) { return; }

    // Background color is r,g,b,o = 0,0,0,0 (black)
    Result[id.xy] = float4(0.0, 0.0, 0.0, 0.0);
}