#pragma kernel RenderBackground; // 0
#pragma kernel RenderFluids; // 1
#pragma kernel RenderRigidBodies; // 2
#pragma kernel RenderRigidBodySprings; // 3
#pragma kernel RenderUI; // 4

#pragma multi_compile _ DRAW_RB_CENTROIDS
#pragma multi_compile _ DRAW_FLUID_OUTLINES
#pragma multi_compile _ DRAW_RB_OUTLINES
#pragma multi_compile _ USE_METABALLS

#include "MathResources.hlsl"
#include "Composition.hlsl"
#include "DataTypes.hlsl"
#include "Constants.hlsl"

const float VisualParticleRadii;
const float MetaballsThreshold;
const float MetaballsEdgeDensityWidth;
const float FluidEdgeWidth;
const float RBEdgeWidth;
const int RBVectorNum;
const int2 Resolution;
const float BackgroundUpScaleFactor;
const float3 BackgroundBrightness;

// Rigid body springs
const int SpringRenderNumPeriods;
const float SpringRenderWidth;
const float SpringRenderHalfMatWidth;
const float SpringRenderRodLength;
const float TaperThresoldNormalised;

const int2 BoundsDims;
const float InvMaxInfluenceRadius;
const int MaxInfluenceRadius;
const int MaxInfluenceRadiusSqr;
const int NumMaterials;
const int2 ChunksNum;
const int ParticlesNum;
const int NumRigidBodies;

RWStructuredBuffer<int> RecordedElements;
RWTexture2D<unorm float4> Result;

Texture2D<unorm float4> Caustics;
Texture2D<unorm float4> UITexture;
Texture2D<unorm float4> Background;
Texture2D<unorm float4> Atlas;

StructuredBuffer<int2> SpatialLookup; 
StructuredBuffer<int> StartIndices;

StructuredBuffer<PData> PDatas;
StructuredBuffer<PType> PTypes;

StructuredBuffer<RigidBody> RigidBodies;
StructuredBuffer<RBVector> RBVectors;

StructuredBuffer<Mat> Materials;

SamplerState bilinearSampler
{
    Filter = MIN_MAG_LINEAR_MIP_POINT; // Bilinear filtering
    AddressU = Clamp; // Use Clamp to prevent wrapping
    AddressV = Clamp;
};

float3 SampleTexture(float2 uv, uint2 texLoc, uint2 texDims, Texture2D<unorm float4> tex)
{
    uint2 texelCoord = texLoc + (uint2)(uv * float2(texDims.x, texDims.y));
    float3 sampleCol = tex.Load(int3(texelCoord, 0)).rgb;
 
    return sampleCol;
}

bool ValidChunk(int2 chunk)
{
    return chunk.x >= 0 && chunk.x < ChunksNum.x && chunk.y >= 0 && chunk.y < ChunksNum.y;
}

int GetChunkKey(int2 chunk)
{
    return chunk.y * ChunksNum.x + chunk.x;
}

uint GetPixelKey(uint2 threadID)
{
    return threadID.y * Resolution.x + threadID.x;
}

float3 TemperatureToRGB(float temperature)
{
    float normalizedTemp = saturate((temperature - 273.0) / (373.0 - 273.0));

    float3 color;

    if (normalizedTemp < 0.1)
    {
        // Light blue to dark blue transition
        color = lerp(float3(0.5, 0.5, 1.0), float3(0.0, 0.0, 1.0), 2.5 * normalizedTemp);
    }
    else if (normalizedTemp < 0.5)
    {
        // Dark blue to green transition
        color = lerp(float3(0.0, 0.0, 1.0), float3(0.0, 1.0, 0.0), 2.5 * (normalizedTemp - 0.1));
    }
    else
    {
        // Green to red transition
        color = lerp(float3(0.0, 1.0, 0.0), float3(1.0, 0.0, 0.0), 2.5 * (normalizedTemp - 0.5));
    }

    return color;
}

float3 VelocityToRGB(float2 velocity, float g)
{
    // Not really normalized
    float normalizedVelLength = length(velocity) * 0.04;

    float r = min(1.0, normalizedVelLength);
    float b = max(0.0, 1 - normalizedVelLength);

    return float3(r, g, b);
}

bool IsPointInsideRB(float2 pos, RigidBody rb)
{
    // Transform the point position into the local coordinate space of the rigid body
    float2 localPos = pos - rb.pos;

    uint intersections = 0;
    uint startIndex = rb.startIndex;
    uint endIndex = rb.endIndex;
    uint numVertices = endIndex - startIndex + 1;

    float2 lastVec = RBVectors[startIndex].pos;
    for (uint i = 0; i < numVertices; i++)
    {
        uint vecIndex = wrapUint(startIndex + i, startIndex, endIndex);
        float2 newVec = RBVectors[vecIndex].pos;

        // Check if the edge from lastVec to newVec intersects the horizontal ray to the right of localPos
        if (IsPointToTheLeftOfLine(localPos, lastVec, newVec)) intersections++;

        lastVec = newVec;
    }

    // The point is inside the polygon if the number of intersections is odd
    bool isInside = (intersections % 2) == 1;

    return isInside;
}

float DstToRB(float2 pos, RigidBody rb)
{
    // Keep the last vector stored to avoid redundant data fetches
    RBVector lastVec = RBVectors[rb.startIndex];

    float minDstSqr = 1.#INF;
    uint startIndex = rb.startIndex;
    uint endIndex = rb.endIndex;
    for (uint vecIndex = startIndex + 1; vecIndex <= endIndex; vecIndex++)
    {
        RBVector newVec = RBVectors[wrapUint(vecIndex, startIndex, endIndex)];

        float2 dst = DstToLineSegment(lastVec.pos + rb.pos, newVec.pos + rb.pos, pos);

        float dstSqr = dot2(dst);
        if (dstSqr < minDstSqr) minDstSqr = dstSqr;

        lastVec = newVec;
    }

    float dst = minDstSqr == 1.#INF ? 1.#INF : sqrt(minDstSqr);

    return dst;
}

float MetaballsDensity(float dstSqr, float invRadius)
{
    float dstR = sqrt(dstSqr) * invRadius;
    return (1 - dstR);
}

float4 GetRenderColor(PData pData)
{
    // visualize velocity / temperature
    float3 rgb = VelocityToRGB(pData.vel, 0);
    // float3 rgb = TemperatureToRGB(pData.temperature);

    return float4(rgb.x, rgb.y, rgb.z, 0);
}

float2 GetTexDims(Texture2D<unorm float4> tex)
{
    float t;
    float2 texDims;
    tex.GetDimensions(0, texDims.x, texDims.y, t);

    return texDims;
}

float3 SampleCaustics(uint2 threadID, float3 sampleColMul)
{
    float2 causticsTexDims = GetTexDims(Caustics);
    float2 baseRes = 512;

    uint2 wrappedThreadID = (threadID / (baseRes / causticsTexDims)) % causticsTexDims;

    float3 fluidCol = sampleColMul * Caustics[wrappedThreadID].rgb;

    return fluidCol;
}

float2 MirrorRepeatUV(float2 uv)
{
    float2 intPart;
    float2 fracPart = frac(uv);
    
    float2 isOdd = floor(uv) - floor(uv / 2.0) * 2.0;
    fracPart = lerp(fracPart, 1.0 - fracPart, step(0.5, isOdd));

    return fracPart;
}

[numthreads(TN_R,TN_R,1)]
void RenderBackground(uint3 id : SV_DispatchThreadID)
{
    float2 uv = MirrorRepeatUV(BackgroundUpScaleFactor * id.xy / (float2)Resolution);
    Result[id.xy] = float4(SampleTexture(uv, 0, GetTexDims(Background), Background) * BackgroundBrightness, 1);
}

float3 BlendWithBackground(float3 color, float opacity, uint2 threadID)
{
    float2 uv = MirrorRepeatUV(BackgroundUpScaleFactor * threadID / (float2)Resolution);
    float transparency = 1 - opacity;
    return transparency > 0 ? color * opacity + transparency * SampleTexture(uv, 0, GetTexDims(Background), Background) * BackgroundBrightness : color;
}

float2 GetPixelPos(uint2 pixelID)
{
    return (float2(pixelID) + .5) * BoundsDims / (float2)Resolution;
}
 
[numthreads(TN_R,TN_R,1)]
void RenderFluids(uint3 id : SV_DispatchThreadID)
{
    float2 pixelPos = GetPixelPos(id.xy);
    int2 chunk = (int2)(pixelPos * InvMaxInfluenceRadius);

    int2 curChunk;
    int lastChunkKey_PType_POrder;
    float totDensity = 0;
    bool particleFound = false;
    bool drawOutline = false;
    bool doContinue = true;
    #if !USE_METABALLS
        float minRadius = min(MaxInfluenceRadius, VisualParticleRadii);
        float minRadiusSqr = minRadius*minRadius;
        float minDstSqr = 1.#INF;
    #endif
    for (int x = -1; x <= 1 && doContinue; x++)
    {
        for (int y = -1; y <= 1 && doContinue; y++)
        {
            curChunk = chunk + int2(x, y);

            if (!ValidChunk(curChunk)) continue;

            int chunkKey = GetChunkKey(curChunk);
            int startIndex = StartIndices[chunkKey];

            int index = startIndex; 
            while (index < ParticlesNum && chunkKey == SpatialLookup[index].y)
            {
                int pIndex = SpatialLookup[index].x;
                PData pData = PDatas[pIndex];

                float dstSqr = dot2(pixelPos - pData.pos);

                #if USE_METABALLS
                    if (dstSqr < MaxInfluenceRadiusSqr)
                    {
                        totDensity += MetaballsDensity(dstSqr, InvMaxInfluenceRadius);

                        #if DRAW_FLUID_OUTLINES
                            if (totDensity > MetaballsThreshold - MetaballsEdgeDensityWidth)
                            {
                                drawOutline = true;
                                lastChunkKey_PType_POrder = pData.lastChunkKey_PType_POrder;
                                particleFound = true;
                            }
                        #endif

                        if (totDensity > MetaballsThreshold)
                        {
                            #if DRAW_FLUID_OUTLINES
                                drawOutline = false;
                            #else
                                lastChunkKey_PType_POrder = pData.lastChunkKey_PType_POrder;
                                particleFound = true;
                            #endif
                            doContinue = false;
                            break;
                        }
                    }
                #else
                    if (dstSqr < min(minRadiusSqr, minDstSqr))
                    {
                        lastChunkKey_PType_POrder = pData.lastChunkKey_PType_POrder;
                        particleFound = true;
                        minDstSqr = dstSqr;

                        #if DRAW_FLUID_OUTLINES
                            if (sqrt(dstSqr) > minRadius - FluidEdgeWidth) drawOutline = true;
                            else drawOutline = false;
                        #endif
                    }
                #endif

                // Increment index each iteration - Chunk particle search algorithm
                index++;
            }
        }
    }

    if (particleFound)
    {
        Mat mat = Materials[PTypes[Extract_PType(lastChunkKey_PType_POrder)].matIndex];

        float3 result;
        if (drawOutline)
        {
            result = mat.edgeCol;
        }
        else
        {
            float3 color = SampleCaustics(id.xy, mat.sampleColMul) + mat.baseCol;
        
            result = BlendWithBackground(color, mat.opacity, id.xy);
        }
    
        Result[id.xy] = float4(result, 1);
    }
}

[numthreads(TN_R,TN_R,1)]
void RenderRigidBodies(uint3 id : SV_DispatchThreadID)
{
    float2 pixelPos = GetPixelPos(id.xy);
    // FIX OUTSIDE BOUNDS CHECK

    int highestRenderPriority = 0;
    bool rigidBodyFound = false;
    bool drawOutline = false;
    int matIndex;
    float3 transformData = 0;
    for (int rbIndex = 0; rbIndex < NumRigidBodies; rbIndex++)
    {
        RigidBody rb = RigidBodies[rbIndex];

        float dstSqr = dot2(pixelPos - rb.pos);

        #if DRAW_RB_CENTROIDS
            if (dstSqr < CENTROID_RADIUS_SQR)
            {
                Result[id.xy] = COL_RED;
                return;
            }
        #endif

        int renderPriority = rb.renderPriority;
        if (renderPriority > highestRenderPriority && dstSqr < rb.maxRadiusSqr)
        {
            if (IsPointInsideRB(pixelPos, rb))
            {
                highestRenderPriority = renderPriority;
                rigidBodyFound = true;
                matIndex = rb.matIndex;
                transformData = float3(rb.pos.x, rb.pos.y, rb.totRot);

                #if DRAW_RB_OUTLINES
                    float dst = DstToRB(pixelPos, rb);
                    if (dst < RBEdgeWidth) drawOutline = true;
                    else drawOutline = false;
                #endif
            }
        }
    }

    if (rigidBodyFound)
    {
        Mat mat = Materials[matIndex];

        float3 result;
        if (drawOutline)
        {
            result = mat.edgeCol;
        }
        else
        {
            float2 localPixelPos = rotate2D(pixelPos - transformData.xy, -transformData.z);
            float2 localUV = MirrorRepeatUV(mat.colTexUpScaleFactor * localPixelPos / (float2)BoundsDims);
    
            float3 color = mat.colTexLoc.x != -1 ? SampleTexture(localUV, mat.colTexLoc, mat.colTexDims, Atlas) * mat.sampleColMul + mat.baseCol : mat.baseCol;

            result = BlendWithBackground(color, mat.opacity, id.xy);
        }

        Result[id.xy] = float4(result, 1);
    }
}

float2 ClosestPointZigZag(float2 localPos, float amplitude, int numPeriods, float startX, float totalLength)
{
    float totalPeriodLength = totalLength / numPeriods;
    float halfPeriod = totalPeriodLength * 0.5;

    // Compute x relative to the start of the zigzag
    float x = localPos.x - startX;

    // Determine the current period index
    int periodIndex = int(floor(x / totalPeriodLength));

    // Position within the current period
    float xInPeriod = x - periodIndex * totalPeriodLength;

    // taper factor
    float t = x / totalLength;
    float taperFactor = saturate(min(t / TaperThresoldNormalised, (1.0 - t) / TaperThresoldNormalised));

    // Apply the tapering to the amplitude
    float taperedAmplitude = amplitude * taperFactor;

    // Compute segment start and end positions with tapered amplitude
    float2 segmentStart, segmentEnd;

    if (xInPeriod < halfPeriod)
    {
        // Ascending segment
        segmentStart = float2(startX + periodIndex * totalPeriodLength, -taperedAmplitude * 0.5);
        segmentEnd = float2(segmentStart.x + halfPeriod, taperedAmplitude * 0.5);
    }
    else
    {
        // Descending segment
        segmentStart = float2(startX + periodIndex * totalPeriodLength + halfPeriod, taperedAmplitude * 0.5);
        segmentEnd = float2(segmentStart.x + halfPeriod, -taperedAmplitude * 0.5);
    }

    // Compute the closest point on the segment to localPos
    float2 segmentVec = segmentEnd - segmentStart;
    float2 pointVec = localPos - segmentStart;

    float u = dot(pointVec, segmentVec) / dot(segmentVec, segmentVec);
    u = clamp(u, 0.0, 1.0);

    float2 closestPoint = segmentStart + u * segmentVec;
    return closestPoint;
}

bool IsOnSpring(float2 localPos, float springLength, float halfSpringWidth)
{
    if (!(localPos.x >= 0.0 && localPos.x <= springLength && abs(localPos.y) <= halfSpringWidth)) return false;
    
    // Check if localPos is on the start or end rods of the spring
    if ((localPos.x < SpringRenderRodLength || localPos.x > springLength - SpringRenderRodLength) && abs(localPos.y) < SpringRenderHalfMatWidth) return true;

    // Check if localPos is within the middle part of the spring
    float midStartX = SpringRenderRodLength;
    float midEndX = springLength - SpringRenderRodLength;

    if (localPos.x >= midStartX && localPos.x <= midEndX)
    {
        float midLength = midEndX - midStartX;

        // Calculate the closest point to a point defined by a zigzag function of x
        float amplitude = halfSpringWidth - SpringRenderHalfMatWidth;
        float2 closestPoint = ClosestPointZigZag(localPos, amplitude, SpringRenderNumPeriods, midStartX, midLength);

        // Check if localPos.y is within the material width of the spring at this x position
        if (length(localPos - closestPoint) <= SpringRenderHalfMatWidth) return true;
    }

    return false;
}

void TintRed(inout float3 color, float redTint)
{
    redTint = saturate(redTint);

    color = lerp(color, float3(1.0, 0.0, 0.0), redTint);
}

float2 NormalizeLocalSpringPos(float2 value, float rodLength, float totalLength, float springLength, float halfSpringWidth)
{
    if (value.x < rodLength)
    {
        // Start rod
        value.x = value.x / rodLength * (rodLength / totalLength);
    }
    else if (value.x > springLength - rodLength)
    {
        // End rod
        value.x = (value.x - (springLength - rodLength)) / rodLength * ((rodLength / totalLength)) + (1.0 - (rodLength / totalLength));
    }
    else
    {
        // Middle zigzag section
        float middleLength = springLength - 2.0 * rodLength;
        value.x = (value.x - rodLength) / middleLength * ((totalLength - 2.0 * rodLength) / totalLength) + (rodLength / totalLength);
    }

    // Normalize value.y
    value.y = (value.y / halfSpringWidth) * 0.5 + 0.5;

    return value;
}

[numthreads(TN_R,TN_R,1)]
void RenderRigidBodySprings(uint3 id : SV_DispatchThreadID)
{
    float2 pixelPos = GetPixelPos(id.xy);

    bool springFound = false;
    float2 posNorm;
    float springForce;
    int matIndex;
    int highestRenderPriority = -1;
    for (uint rbIndex = 0; rbIndex < (uint)NumRigidBodies; rbIndex++)
    {
        RigidBody rbA = RigidBodies[rbIndex];
        float stiffness = rbA.springStiffness;

        // Check if:
        // 1. The rigid body is linked to another rigid body
        // 2. The link is a non-rigid constraint (i.e., if springLength != 0)
        // 3. The rigid body render priority is higher than the currently rendered spring
        bool isLinked = rbA.linkedRBIndex != -1 && rbA.linkedRBIndex != (int)rbIndex;
        bool rigidConstraint = stiffness == 0.0;
        int renderPriority = rbA.renderPriority;
        if (!isLinked || rigidConstraint || renderPriority <= highestRenderPriority) continue;

        RigidBody rbB = RigidBodies[rbA.linkedRBIndex];

        float2 worldLinkPosA = rbA.pos + rotate2D(rbA.localLinkPosThisRB, rbA.totRot);
        float2 worldLinkPosB = rbB.pos + rotate2D(rbA.localLinkPosOtherRB, rbB.totRot);
        
        // (localSpringStart == 0 after the transformations)
        float2 localSpringEnd = worldLinkPosB - worldLinkPosA;
        float springLength = length(localSpringEnd);

        // Avoid drawing the springs with 0 length
        if (springLength == 0.0) continue;

        // Compute the angle to rotate so that localSpringEnd aligns with x-axis
        float theta = atan2(localSpringEnd.y, localSpringEnd.x);

        // Compute the vector from spring start to pixel position
        float2 pixelVec = pixelPos - worldLinkPosA;

        // Rotate the pixel vector into the spring's local coordinate system
        float2 localPixelPos = rotate2D(pixelVec, -theta);

        // Now the spring starts at (0,0), ends at (springLength, 0)
        // Check if the pixel is within the spring's area
        float halfSpringWidth = SpringRenderWidth * 0.5;
        float springRenderHalfMatWidthSqr = SpringRenderHalfMatWidth*SpringRenderHalfMatWidth;

        bool isOnSpring = IsOnSpring(localPixelPos, springLength, halfSpringWidth);
        if (isOnSpring)
        {
            springFound = true;
            highestRenderPriority = renderPriority;
            springForce = rbA.recordedSpringForce;
            matIndex = rbA.springMatIndex;
            posNorm = NormalizeLocalSpringPos(localPixelPos, SpringRenderRodLength, rbA.springRestLength, springLength, halfSpringWidth);
        }
    }

    if (springFound)
    {
        Mat mat = Materials[matIndex];

        float2 uv = MirrorRepeatUV(mat.colTexUpScaleFactor * posNorm / (float2)BoundsDims);

        float3 color = mat.colTexLoc.x != -1 ? SampleTexture(uv, mat.colTexLoc, mat.colTexDims, Atlas) * mat.sampleColMul + mat.baseCol : mat.baseCol;

        float redTint = RED_TINT_FACTOR * springForce;
        TintRed(color, redTint);
        
        Result[id.xy] = float4(color, 1);
    }
}

[numthreads(TN_R,TN_R,1)]
void RenderUI(uint3 id : SV_DispatchThreadID)
{
    float4 uiColor = UITexture[id.xy];
    if (uiColor.a != 0) Result[id.xy] = uiColor;
}