#pragma kernel ResetDatas; // 0
#pragma kernel RenderFluids; // 1
#pragma kernel RenderRigidBodies; // 2
#pragma kernel ApplyMaterials; // 3

#pragma multi_compile _ DRAW_RB_CENTROIDS
#pragma multi_compile _ DRAW_RB_EDGES
#pragma multi_compile _ USE_METABALLS

#include "MathResources.hlsl"
#include "Composition.hlsl"
#include "DataTypes.hlsl"
#include "Constants.hlsl"

const float VisualParticleRadii;
const float MetaballsThreshold;
const float EdgeWidth;
const int RBVectorNum;
const int2 Resolution;
const float3 BackgroundColor;
const float3 EdgeColor;

const int2 BoundsDims;
const float InvMaxInfluenceRadius;
const int MaxInfluenceRadius;
const int MaxInfluenceRadiusSqr;
const int NumMaterials;
const int2 ChunksNum;
const int ParticlesNum;
const int RBodiesNum;

RWStructuredBuffer<int> RecordedElements;
RWTexture2D<unorm float4> TransformDatas;
RWTexture2D<unorm float4> Result;

Texture2D<unorm float4> Caustics;
Texture2D<unorm float4> UITexture;
Texture2D<unorm float4> Background;

StructuredBuffer<int2> SpatialLookup; 
StructuredBuffer<int> StartIndices;

StructuredBuffer<PData> PDatas;
StructuredBuffer<PType> PTypes;

StructuredBuffer<RigidBody> RigidBodies;
StructuredBuffer<RBVector> RBVectors;

StructuredBuffer<Mat> Materials;

bool ValidChunk(int2 chunk)
{
    return chunk.x >= 0 && chunk.x < ChunksNum.x && chunk.y >= 0 && chunk.y < ChunksNum.y;
}

int GetChunkKey(int2 chunk)
{
    return chunk.y * ChunksNum.x + chunk.x;
}

uint GetPixelKey(uint2 threadID)
{
    return threadID.y * Resolution.x + threadID.x;
}

float3 TemperatureToRGB(float temperature)
{
    float normalizedTemp = saturate((temperature - 273.0) / (373.0 - 273.0));

    float3 color;

    if (normalizedTemp < 0.1)
    {
        // Light blue to dark blue transition
        color = lerp(float3(0.5, 0.5, 1.0), float3(0.0, 0.0, 1.0), 2.5 * normalizedTemp);
    }
    else if (normalizedTemp < 0.5)
    {
        // Dark blue to green transition
        color = lerp(float3(0.0, 0.0, 1.0), float3(0.0, 1.0, 0.0), 2.5 * (normalizedTemp - 0.1));
    }
    else
    {
        // Green to red transition
        color = lerp(float3(0.0, 1.0, 0.0), float3(1.0, 0.0, 0.0), 2.5 * (normalizedTemp - 0.5));
    }

    return color;
}

float3 VelocityToRGB(float2 velocity, float g)
{
    // Not really normalized
    float normalizedVelLength = length(velocity) * 0.04;

    float r = min(1.0, normalizedVelLength);
    float b = max(0.0, 1 - normalizedVelLength);

    return float3(r, g, b);
}

bool IsPointInsideRB(float2 pos, RigidBody rb)
{
    // Transform the point position into the local coordinate space of the rigid body
    float2 localPos = pos - rb.pos;

    uint intersections = 0;
    uint startIndex = rb.startIndex;
    uint endIndex = rb.endIndex;
    uint numVertices = endIndex - startIndex + 1;

    float2 lastVec = RBVectors[startIndex].pos;
    for (uint i = 0; i < numVertices; i++)
    {
        uint vecIndex = wrapUint(startIndex + i, startIndex, endIndex);
        float2 newVec = RBVectors[vecIndex].pos;

        // Check if the edge from lastVec to newVec intersects the horizontal ray to the right of localPos
        if (IsPointToTheLeftOfLine(localPos, lastVec, newVec)) intersections++;

        lastVec = newVec;
    }

    // The point is inside the polygon if the number of intersections is odd
    bool isInside = (intersections % 2) == 1;

    return isInside;
}

float DstToRB(float2 pos, RigidBody rb)
{
    // Keep the last vector stored to avoid redundant data fetches
    RBVector lastVec = RBVectors[rb.startIndex];

    float minDstSqr = 1.#INF;
    uint startIndex = rb.startIndex;
    uint endIndex = rb.endIndex;
    for (uint vecIndex = startIndex + 1; vecIndex <= endIndex; vecIndex++)
    {
        RBVector newVec = RBVectors[wrapUint(vecIndex, startIndex, endIndex)];

        float2 dst = DstToLineSegment(lastVec.pos + rb.pos, newVec.pos + rb.pos, pos);

        float dstSqr = dot2(dst);
        if (dstSqr < minDstSqr) minDstSqr = dstSqr;

        lastVec = newVec;
    }

    float dst = minDstSqr == 1.#INF ? 1.#INF : sqrt(minDstSqr);

    return dst;
}

float MetaballsDensity(float dstSqr, float invRadius)
{
    float dstR = sqrt(dstSqr) * invRadius;
    return (1 - dstR);
}

float4 GetRenderColor(PData pData)
{
    // visualize velocity / temperature
    float3 rgb = VelocityToRGB(pData.vel, 0);
    // float3 rgb = TemperatureToRGB(pData.temperature);

    return float4(rgb.x, rgb.y, rgb.z, 0.0);
}

static const float3 COLOR_MULTIPLIER = float3(0.0, 0.0, 0.4);
static const float3 COLOR_ADDITION = float3(0.0, 0.0, 0.6);
float4 SampleCaustics(uint2 threadID, float alpha)
{
    float t;
    float2 causticsTexDims;
    float2 baseRes = 512;
    Caustics.GetDimensions(0, causticsTexDims.x, causticsTexDims.y, t);

    uint2 wrappedThreadID = (threadID / (baseRes / causticsTexDims)) % causticsTexDims;

    float sample = Caustics[wrappedThreadID].r;

    float3 fluidCol = sample * COLOR_MULTIPLIER + COLOR_ADDITION;

    float transparency = 1 - alpha;
    float3 combinedColor = fluidCol * alpha + Background[threadID.xy].xyz * transparency;
    
    return float4(combinedColor.r, combinedColor.g, combinedColor.b, 1.0);
}

[numthreads(TN_R,TN_R,1)]
void ResetDatas(uint3 id : SV_DispatchThreadID)
{
    RecordedElements[GetPixelKey(id.xy)] = 0;
}
 
[numthreads(TN_R,TN_R,1)]
void RenderFluids(uint3 id : SV_DispatchThreadID)
{
    float2 pixelPos = (float2(id.xy) + .5) * BoundsDims / (float2)Resolution;
    int2 chunk = (int2)(pixelPos * InvMaxInfluenceRadius);

    int2 curChunk;
    int lastChunkKey_PType_POrder;
    float totDensity = 0;
    bool particleFound = false;
    bool doContinue = true;
    #if !USE_METABALLS
        float minRadiusSqr = pow(min(MaxInfluenceRadius, VisualParticleRadii), 2);
        float minDstSqr = 1.#INF;
    #endif
    for (int x = -1; x <= 1 && doContinue; x++)
    {
        for (int y = -1; y <= 1 && doContinue; y++)
        {
            curChunk = chunk + int2(x, y);

            if (!ValidChunk(curChunk)) continue;

            int chunkKey = GetChunkKey(curChunk);
            int startIndex = StartIndices[chunkKey];

            int index = startIndex; 
            while (index < ParticlesNum && chunkKey == SpatialLookup[index].y)
            {
                int pIndex = SpatialLookup[index].x;
                PData pData = PDatas[pIndex];

                float dstSqr = dot2(pixelPos - pData.pos);

                #if USE_METABALLS
                    if (dstSqr < MaxInfluenceRadiusSqr)
                    {
                        totDensity += MetaballsDensity(dstSqr, InvMaxInfluenceRadius);

                        if (totDensity > MetaballsThreshold)
                        {
                            lastChunkKey_PType_POrder = pData.lastChunkKey_PType_POrder;
                            particleFound = true;
                            doContinue = false;
                            break;
                        }
                    }
                #else
                    if (dstSqr < min(minRadiusSqr, minDstSqr))
                    {
                        lastChunkKey_PType_POrder = pData.lastChunkKey_PType_POrder;
                        particleFound = true;
                        minDstSqr = dstSqr;
                    }
                #endif

                // Increment index each iteration - Chunk particle search algorithm
                index++;
            }
        }
    }

    if (particleFound)
    {
        int matIndex = PTypes[Extract_PType(lastChunkKey_PType_POrder)].matIndex;

        // if (particleFound) RecordedElements[id.xy].x = StoreFluidMatIndex(matIndex);
        RecordedElements[GetPixelKey(id.xy)] = StoreFluidMatIndex(matIndex);
    }
}

[numthreads(TN_R,TN_R,1)]
void RenderRigidBodies(uint3 id : SV_DispatchThreadID)
{
    float2 pixelPos = (float2(id.xy) + .5) * BoundsDims / (float2)Resolution;

    int highestRenderPriority = 0;
    bool rigidBodyFound = false;
    int matIndex;
    float3 transformData = 0;
    for (int rbIndex = 0; rbIndex < RBodiesNum; rbIndex++)
    {
        RigidBody rb = RigidBodies[rbIndex];
        int renderPriority = rb.renderPriority;
        
        if (renderPriority > highestRenderPriority)
        {
            if (IsPointInsideRB(pixelPos, rb))
            {
                highestRenderPriority = renderPriority;
                rigidBodyFound = true;
                matIndex = rb.matIndex;
                transformData = float3(rb.pos.x, rb.pos.y, rb.totRot);
            }
        }
    }

    // if (rigidBodyFound) RecordedElements[id.xy].x = StoreRBMatIndex(matIndex);
    if (rigidBodyFound)
    {
        uint pixelKey = GetPixelKey(id.xy);
        RecordedElements[pixelKey] = StoreRBMatIndex(matIndex);
        TransformDatas[id.xy] = float4(transformData, 0);
    }
}
 
[numthreads(TN_R,TN_R,1)]
void ApplyMaterials(uint3 id : SV_DispatchThreadID)
{
    int storedMatIndex = RecordedElements[GetPixelKey(id.xy)];
    if (storedMatIndex == 0)
    {
        Result[id.xy] = float4(Background[id.xy].rgb, 1.0);
        return;
    }

    bool fluid_RigidBody = storedMatIndex > 0;

    int matIndex = fluid_RigidBody ? RetrieveStoredFluidMatIndex(storedMatIndex) : RetrieveStoredRBMatIndex(storedMatIndex);
    Mat mat = Materials[matIndex];
    
    float4 color;
    if (fluid_RigidBody)
    {
        color = SampleCaustics(id.xy, mat.alpha);
    }
    else
    {
        float4 transformData = TransformDatas[id.xy];
        color = 1;
    }

    float transparency = 1 - color.a;
    
    float4 result = transparency > 0 ? float4(color.rgb, 1.0) * color.a + transparency * float4(Background[id.xy].rgb, 1.0) : color;

    Result[id.xy] = result;
}