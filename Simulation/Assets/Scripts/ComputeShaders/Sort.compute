#pragma kernel CalculateChunkKeys // 0
#pragma kernel SortIteration // 1
#pragma kernel PrepStartIndices // 2
#pragma kernel PopulateStartIndices // 3

#pragma kernel PopulateChunkSizes // 4
#pragma kernel PopulateSpringCapacities // 5
#pragma kernel CopySpringCapacities // 6
#pragma kernel ParallelPrefixSumScan // 7
#pragma kernel CopySpringStartIndicesBuffer // 8

#pragma kernel PopulateSortedStickyRequests // 9
#pragma kernel SRSortIteration // 10

#include "MathResources.hlsl"

// https://en.wikipedia.org/wiki/Bitonic_sorter - alternative visual representation

static const int ThreadsNum = 512;
static const int ThreadsNumChunkDivider = 10;

const int MaxInfluenceRadius;
const int ChunkNumW;
const int ChunkNumH;
const int ChunkNum;
const int ChunkNumNextPow2;
const int ParticlesNum;

// Per-iteration-set constants
const bool BrownPinkSort; // True -> BrownSort, False -> PinkSort
const int SpatialLookupLog2Length;
const int BlockLen;
const int BlocksNum;
const int IOOR;

const int SortedStickyRequestsLength;
const int SortedStickyRequestsLog2Length;

const bool SRBrownPinkSort; // True -> BrownSort, False -> PinkSort
const int SRBlockLen;
const int SRblocksNum;

const bool FrameBufferCycle;
const bool StepBufferCycle;
const int IndexOffset;
const int HalfOffset;
const int TotIndicesToProcess;

RWStructuredBuffer<int2> SpatialLookup; // [ParticlesNum](particleIndex, ChunkKey)
RWStructuredBuffer<int> StartIndices;

RWStructuredBuffer<int> ChunkSizes;
RWStructuredBuffer<int> SpringCapacities;
RWStructuredBuffer<int> SpringStartIndices_dbA; // Result A
RWStructuredBuffer<int> SpringStartIndices_dbB; // Result B
RWStructuredBuffer<int> SpringStartIndices_dbC; // Support

struct PTypeStruct
{
    float TargetDensity;
    int MaxInfluenceRadius;
    float Pressure;
    float NearPressure;
    float Damping;
    float Viscocity;
    float Elasticity;
    float Plasticity;
    float Stickyness;
    float Gravity;
    float colorG;
};
RWStructuredBuffer<PTypeStruct> PTypes;

struct PDataStruct
{
    float2 PredPosition;
    float2 Position;
    float2 Velocity;
    float2 LastVelocity;
    float Density;
    float NearDensity;
    int POrder;
    int LastPOrder;
    int LastChunkKey;
    int PType;
};
RWStructuredBuffer<PDataStruct> PData;

struct StickynessRequestStruct
{
    int pIndex;
    int StickyLineIndex;
    float2 StickyLineDst;
    float absDstToLineSqr;
    float RBStickyness;
    float RBStickynessRange;
};
ConsumeStructuredBuffer<StickynessRequestStruct> StickynessReqsCONSUME;
RWStructuredBuffer<StickynessRequestStruct> SortedStickyRequests;

bool ValidChunk(int ChunkX, int ChunkY)
{
    if (ChunkX >= 0 && ChunkX < ChunkNumW && ChunkY >= 0 && ChunkY < ChunkNumH) {return true;}
    return false;
}

int GetChunkKey(int pIndex, float2 pos)
{
    int chunkX = (int)(pos.x / MaxInfluenceRadius);
    int chunkY = (int)(pos.y / MaxInfluenceRadius);
    int chunkKey = chunkY * ChunkNumW + chunkX;
    return chunkKey;
}

void BrownSort(int lowRef)
{
    int relBlock = (int)(2 * lowRef / (uint)BlockLen);
    int relPos = lowRef % (0.5 * BlockLen);

    int lowIndex = relBlock * BlockLen + relPos;
    int highIndex = relBlock * BlockLen + BlockLen - 1 - relPos;

    if (SpatialLookup[lowIndex].y > SpatialLookup[highIndex].y)
    {
        int2 highIndexValue = SpatialLookup[highIndex];
        int2 lowIndexValue = SpatialLookup[lowIndex];
        SpatialLookup[highIndex] = lowIndexValue;
        SpatialLookup[lowIndex] = highIndexValue;
    }
    else if (SpatialLookup[lowIndex].y == SpatialLookup[highIndex].y)
    {
        if (SpatialLookup[lowIndex].x > SpatialLookup[highIndex].x)
        {
            int2 highIndexValue = SpatialLookup[highIndex];
            int2 lowIndexValue = SpatialLookup[lowIndex];
            SpatialLookup[highIndex] = lowIndexValue;
            SpatialLookup[lowIndex] = highIndexValue;
        }
    }
}

void PinkSort(int lowRef)
{
    int relBlock = (int)(2 * lowRef / (uint)BlockLen);
    int relPos = lowRef % (0.5 * BlockLen);

    int lowIndex = relBlock * BlockLen + relPos;
    int highIndex = relBlock * BlockLen + relPos + (int)(BlockLen * 0.5);

    if (SpatialLookup[lowIndex].y > SpatialLookup[highIndex].y)
    {
        int2 highIndexValue = SpatialLookup[highIndex];
        int2 lowIndexValue = SpatialLookup[lowIndex];
        SpatialLookup[highIndex] = lowIndexValue;
        SpatialLookup[lowIndex] = highIndexValue;
    }
    else if (SpatialLookup[lowIndex].y == SpatialLookup[highIndex].y)
    {
        if (SpatialLookup[lowIndex].x > SpatialLookup[highIndex].x)
        {
            int2 highIndexValue = SpatialLookup[highIndex];
            int2 lowIndexValue = SpatialLookup[lowIndex];
            SpatialLookup[highIndex] = lowIndexValue;
            SpatialLookup[lowIndex] = highIndexValue;
        }
    }
}

int GetNeighboorParticlesNum(int ChunkKey)
{
    int chunkX = (uint)ChunkKey % ChunkNumW;
    int chunkY = (int)((uint)ChunkKey / ChunkNumW);

    int neighboorParticlesNum = 0;
    for (int x = -1; x <= 1; x++)
    {
        int curChunkX = chunkX + x;

        for (int y = -1; y <= 1; y++)
        {
            int curChunkY = chunkY + y;

            if (ValidChunk(curChunkX, curChunkY))
            {
                int neighboorChunkKey = curChunkY * ChunkNumW + curChunkX;
                neighboorParticlesNum += ChunkSizes[neighboorChunkKey];
            }
        }
    }
    return neighboorParticlesNum * ChunkSizes[ChunkKey];
}

[numthreads(ThreadsNum,1,1)]
void CalculateChunkKeys (uint3 id : SV_DispatchThreadID)
{
    int i = id.x;

    int chunkKey = GetChunkKey(i, PData[i].Position);
    SpatialLookup[i] = int2(i, chunkKey);
}

[numthreads(ThreadsNum,1,1)]
void SortIteration (uint3 id : SV_DispatchThreadID)
{
    int lowRef = id.x;
    if (BrownPinkSort)
    {
        BrownSort(lowRef);
    }
    else
    {
        PinkSort(lowRef);
    }
}

// This is unnecessary IF PARTICLESNUM STAYS CONSTANT
[numthreads(ThreadsNum,1,1)]
void PrepStartIndices (uint3 id : SV_DispatchThreadID)
{
    int i = id.x;

    StartIndices[i] = IOOR;
}

[numthreads(ThreadsNum,1,1)]
void PopulateStartIndices (uint3 id : SV_DispatchThreadID)
{
    int i = id.x;
    
    int ChunkKey = SpatialLookup[i].y;
    int LastChunkKey = IOOR;

    if (i != 0)
    {
        LastChunkKey = SpatialLookup[i-1].y;
    }

    if (ChunkKey != LastChunkKey)
    {
        StartIndices[ChunkKey] = i;
    }
}

[numthreads(ThreadsNumChunkDivider,1,1)]
void PopulateChunkSizes (uint3 id : SV_DispatchThreadID)
{
    int ChunkKey = id.x - 1;

    int startIndex = StartIndices[ChunkKey];

    int neighboorCount = 0;
    int Index = startIndex; 
    while (Index < ParticlesNum && ChunkKey == SpatialLookup[Index].y)
    {
        Index += 1;
        neighboorCount += 1;
    }
    ChunkSizes[ChunkKey] = neighboorCount;
}

[numthreads(ThreadsNumChunkDivider,1,1)]
void PopulateSpringCapacities (uint3 id : SV_DispatchThreadID)
{
    int ChunkKey = id.x;

    int SpringCapacity = GetNeighboorParticlesNum(ChunkKey);

    SpringCapacities[ChunkKey] = SpringCapacity;
}

[numthreads(ThreadsNumChunkDivider,1,1)]
void CopySpringCapacities (uint3 id : SV_DispatchThreadID)
{
    // Copying both should be unnecessary
    int ChunkKey = id.x;
    if (ChunkKey < ChunkNum)
    {
        if (FrameBufferCycle)
        {
            SpringStartIndices_dbA[ChunkKey] = SpringCapacities[ChunkKey];
        }
        else
        {
            SpringStartIndices_dbB[ChunkKey] = SpringCapacities[ChunkKey];
        }
        SpringStartIndices_dbC[ChunkKey] = SpringCapacities[ChunkKey];
    }
}

[numthreads(ThreadsNumChunkDivider,1,1)]
void ParallelPrefixSumScan (uint3 id : SV_DispatchThreadID)
{
    if (id.x <= (uint)TotIndicesToProcess)
    {
        int i = id.x + IndexOffset;

        if (i >= ChunkNum) { return; }

        if (FrameBufferCycle)
        {
            // A -> C
            if (StepBufferCycle)
            {
                int storedVal = SpringStartIndices_dbA[i] + SpringStartIndices_dbA[i - IndexOffset];
                SpringStartIndices_dbC[i] = storedVal;
            }
            // C -> A
            else
            {
                int storedVal = SpringStartIndices_dbC[i] + SpringStartIndices_dbC[i - IndexOffset];
                SpringStartIndices_dbA[i] = storedVal;
            }
        }
        // B <-> C 
        else
        {
            // B -> C
            if (StepBufferCycle)
            {
                int storedVal = SpringStartIndices_dbB[i] + SpringStartIndices_dbB[i - IndexOffset];
                SpringStartIndices_dbC[i] = storedVal;
            }
            // C -> B
            else
            {
                int storedVal = SpringStartIndices_dbC[i] + SpringStartIndices_dbC[i - IndexOffset];
                SpringStartIndices_dbB[i] = storedVal;
            }
        }
    }
    else
    { 
        int id_x = id.x - TotIndicesToProcess;
        if (id_x > HalfOffset) { return; }

        int i = id_x + HalfOffset;

        if (FrameBufferCycle)
        {
            // A -> C
            if (StepBufferCycle)
            {
                SpringStartIndices_dbC[i] = SpringStartIndices_dbA[i];
            }
            // C -> A
            else
            {
                SpringStartIndices_dbA[i] = SpringStartIndices_dbC[i];
            }
        }
        // B <-> C 
        else
        {
            // B -> C
            if (StepBufferCycle)
            {
                SpringStartIndices_dbC[i] = SpringStartIndices_dbB[i];
            }
            // C -> B
            else
            {
                SpringStartIndices_dbB[i] = SpringStartIndices_dbC[i];
            }
        }
    }
}

[numthreads(ThreadsNumChunkDivider,1,1)]
void CopySpringStartIndicesBuffer (uint3 id : SV_DispatchThreadID)
{
    int i = id.x;
    // C -> A
    if (FrameBufferCycle)
    {
        SpringStartIndices_dbA[i] = SpringStartIndices_dbC[i];
    }
    // C -> B
    else
    {
        SpringStartIndices_dbB[i] = SpringStartIndices_dbC[i];
    }
}

void SRBrownSort(int lowRef)
{
    int relBlock = (int)(2 * lowRef / (uint)SRBlockLen);
    int relPos = lowRef % (0.5 * SRBlockLen);

    int lowIndex = relBlock * SRBlockLen + relPos;
    int highIndex = relBlock * SRBlockLen + SRBlockLen - 1 - relPos;

    if (SortedStickyRequests[lowIndex].pIndex > SortedStickyRequests[highIndex].pIndex)
    {
        StickynessRequestStruct highIndexValue = SortedStickyRequests[highIndex];
        StickynessRequestStruct lowIndexValue = SortedStickyRequests[lowIndex];
        SortedStickyRequests[highIndex] = lowIndexValue;
        SortedStickyRequests[lowIndex] = highIndexValue;
    }
}

void SRPinkSort(int lowRef)
{
    int relBlock = (int)(2 * lowRef / (uint)SRBlockLen);
    int relPos = lowRef % (0.5 * SRBlockLen);

    int lowIndex = relBlock * SRBlockLen + relPos;
    int highIndex = relBlock * SRBlockLen + relPos + (int)(SRBlockLen * 0.5);

    if (SortedStickyRequests[lowIndex].pIndex > SortedStickyRequests[highIndex].pIndex)
    {
        StickynessRequestStruct highIndexValue = SortedStickyRequests[highIndex];
        StickynessRequestStruct lowIndexValue = SortedStickyRequests[lowIndex];
        SortedStickyRequests[highIndex] = lowIndexValue;
        SortedStickyRequests[lowIndex] = highIndexValue;
    }
}

[numthreads(ThreadsNum,1,1)]
void PopulateSortedStickyRequests (uint3 id : SV_DispatchThreadID)
{
    int i = id.x;

    StickynessRequestStruct stickynessRequest = StickynessReqsCONSUME.Consume();

    SortedStickyRequests[i] = stickynessRequest;
}

[numthreads(ThreadsNum,1,1)]
void SRSortIteration (uint3 id : SV_DispatchThreadID)
{
    int lowRef = id.x;
    if (SRBrownPinkSort)
    {
        SRBrownSort(lowRef);
    }
    else
    {
        SRPinkSort(lowRef);
    }
}