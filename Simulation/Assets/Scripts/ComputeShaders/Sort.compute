#pragma kernel CalculateChunkKeys
#pragma kernel SortIteration
#pragma kernel PrepStartIndices
#pragma kernel PopulateStartIndices

#pragma kernel PopulateSortedStickyRequests
#pragma kernel SRSortIteration

#include "MathResources.hlsl"

// https://en.wikipedia.org/wiki/Bitonic_sorter - alternative visual representation

static const int ThreadsNum = 512;

const int MaxInfluenceRadius;
const int ChunkNumW;

// Per-iteration-set constants
const bool BrownPinkSort; // True -> BrownSort, False -> PinkSort
const int SpatialLookupLog2Length;
const int BlockLen;
const int BlocksNum;
const int IOOR;

const int SortedStickyRequestsLength;
const int SortedStickyRequestsLog2Length;

const bool SRBrownPinkSort; // True -> BrownSort, False -> PinkSort
const int SRBlockLen;
const int SRblocksNum;

RWStructuredBuffer<int2> SpatialLookup; // [ParticlesNum](particleIndex, ChunkKey)
RWStructuredBuffer<int> StartIndices;

struct PTypeStruct
{
    float TargetDensity;
    int MaxInfluenceRadius;
    float Pressure;
    float NearPressure;
    float Damping;
    float Viscocity;
    float Elasticity;
    float Plasticity;
    float Stickyness;
    float Gravity;
    float colorG;
};
RWStructuredBuffer<PTypeStruct> PTypes;

struct PDataStruct
{
    float2 PredPosition;
    float2 Position;
    float2 Velocity;
    float2 LastVelocity;
    float Density;
    float NearDensity;
    int PType;
};
RWStructuredBuffer<PDataStruct> PData;

struct StickynessRequestStruct
{
    int pIndex;
    int StickyLineIndex;
    float2 StickyLineDst;
    float absDstToLineSqr;
    float RBStickyness;
    float RBStickynessRange;
};
ConsumeStructuredBuffer<StickynessRequestStruct> StickynessReqsCONSUME;
RWStructuredBuffer<StickynessRequestStruct> SortedStickyRequests;

int GetChunkKey(int pIndex, float2 pos)
{
    int chunkX = (int)(pos.x / MaxInfluenceRadius);
    int chunkY = (int)(pos.y / MaxInfluenceRadius);
    int chunkKey = chunkY * ChunkNumW + chunkX;
    return chunkKey;
}

void BrownSort(int lowRef)
{
    int relBlock = (int)(2 * lowRef / (uint)BlockLen);
    int relPos = lowRef % (0.5 * BlockLen);

    int lowIndex = relBlock * BlockLen + relPos;
    int highIndex = relBlock * BlockLen + BlockLen - 1 - relPos;

    if (SpatialLookup[lowIndex].y > SpatialLookup[highIndex].y)
    {
        int2 highIndexValue = SpatialLookup[highIndex];
        int2 lowIndexValue = SpatialLookup[lowIndex];
        SpatialLookup[highIndex] = lowIndexValue;
        SpatialLookup[lowIndex] = highIndexValue;
    }
}

void PinkSort(int lowRef)
{
    int relBlock = (int)(2 * lowRef / (uint)BlockLen);
    int relPos = lowRef % (0.5 * BlockLen);

    int lowIndex = relBlock * BlockLen + relPos;
    int highIndex = relBlock * BlockLen + relPos + (int)(BlockLen * 0.5);

    if (SpatialLookup[lowIndex].y > SpatialLookup[highIndex].y)
    {
        int2 highIndexValue = SpatialLookup[highIndex];
        int2 lowIndexValue = SpatialLookup[lowIndex];
        SpatialLookup[highIndex] = lowIndexValue;
        SpatialLookup[lowIndex] = highIndexValue;
    }
}

[numthreads(ThreadsNum,1,1)]
void CalculateChunkKeys (uint3 id : SV_DispatchThreadID)
{
    int i = id.x;

    int chunkKey = GetChunkKey(i, PData[i].PredPosition);
    SpatialLookup[i] = int2(i, chunkKey);
}

[numthreads(ThreadsNum,1,1)]
void SortIteration (uint3 id : SV_DispatchThreadID)
{
    int lowRef = id.x;
    if (BrownPinkSort)
    {
        BrownSort(lowRef);
    }
    else
    {
        PinkSort(lowRef);
    }
}

// This is unnecessary IF PARTICLESNUM STAYS CONSTANT
[numthreads(ThreadsNum,1,1)]
void PrepStartIndices (uint3 id : SV_DispatchThreadID)
{
    int i = id.x;

    StartIndices[i] = IOOR;
}

[numthreads(ThreadsNum,1,1)]
void PopulateStartIndices (uint3 id : SV_DispatchThreadID)
{
    int i = id.x;
    
    int ChunkKey = SpatialLookup[i].y;
    int LastChunkKey = IOOR;

    if (i != 0)
    {
        LastChunkKey = SpatialLookup[i-1].y;
    }

    if (ChunkKey != LastChunkKey)
    {
        StartIndices[ChunkKey] = i;
    }
}



void SRBrownSort(int lowRef)
{
    int relBlock = (int)(2 * lowRef / (uint)SRBlockLen);
    int relPos = lowRef % (0.5 * SRBlockLen);

    int lowIndex = relBlock * SRBlockLen + relPos;
    int highIndex = relBlock * SRBlockLen + SRBlockLen - 1 - relPos;

    if (SortedStickyRequests[lowIndex].pIndex > SortedStickyRequests[highIndex].pIndex)
    {
        StickynessRequestStruct highIndexValue = SortedStickyRequests[highIndex];
        StickynessRequestStruct lowIndexValue = SortedStickyRequests[lowIndex];
        SortedStickyRequests[highIndex] = lowIndexValue;
        SortedStickyRequests[lowIndex] = highIndexValue;
    }
}

void SRPinkSort(int lowRef)
{
    int relBlock = (int)(2 * lowRef / (uint)SRBlockLen);
    int relPos = lowRef % (0.5 * SRBlockLen);

    int lowIndex = relBlock * SRBlockLen + relPos;
    int highIndex = relBlock * SRBlockLen + relPos + (int)(SRBlockLen * 0.5);

    if (SortedStickyRequests[lowIndex].pIndex > SortedStickyRequests[highIndex].pIndex)
    {
        StickynessRequestStruct highIndexValue = SortedStickyRequests[highIndex];
        StickynessRequestStruct lowIndexValue = SortedStickyRequests[lowIndex];
        SortedStickyRequests[highIndex] = lowIndexValue;
        SortedStickyRequests[lowIndex] = highIndexValue;
    }
}


[numthreads(ThreadsNum,1,1)]
void PopulateSortedStickyRequests (uint3 id : SV_DispatchThreadID)
{
    int i = id.x;

    StickynessRequestStruct stickynessRequest = StickynessReqsCONSUME.Consume();

    SortedStickyRequests[i] = stickynessRequest;
}

[numthreads(ThreadsNum,1,1)]
void SRSortIteration (uint3 id : SV_DispatchThreadID)
{
    int lowRef = id.x;
    if (SRBrownPinkSort)
    {
        SRBrownSort(lowRef);
    }
    else
    {
        SRPinkSort(lowRef);
    }
}
