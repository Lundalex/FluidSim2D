#pragma kernel RbRbCollisions
#pragma kernel RbParticleCollisions
#pragma kernel PopulateTraversedChunks
#pragma kernel ConsumeTraversedChunks

#include "MathResources.hlsl"

static const int ThreadsNum = 32;

// Constants
const int ChunkNumW;
const int ChunkNumH;
const int Width;
const int Height;
const int ParticlesNum;
const int RBodiesNum;
const int MaxInfluenceRadius;

const float Damping;
// const float Viscocity;
const float Gravity;
const float RbElasticity;
const float RbPStickyRadius;
const float RbPStickyness;
const float BorderPadding;

// Per-timestep-set constants
const float DeltaTime;

// Particles - Buffers
RWStructuredBuffer<int2> SpatialLookup; // [ParticlesNum](particleIndex, ChunkKey)
RWStructuredBuffer<int> StartIndices;

struct PTypeStruct
{
    float TargetDensity;
    int MaxInfluenceRadius;
    float Pressure;
    float NearPressure;
    float Damping;
    float Viscocity;
    float Elasticity;
    float Plasticity;
    float Gravity;
    float colorG;
};
RWStructuredBuffer<PTypeStruct> PTypes;

struct PDataStruct
{
    float2 PredPosition;
    float2 Position;
    float2 Velocity;
    float2 LastVelocity;
    float Density;
    float NearDensity;
    int PType;
};
RWStructuredBuffer<PDataStruct> PData;

struct RBDataStruct
{
    float2 Position;
    float2 Velocity;
    int2 LineIndices;
};
RWStructuredBuffer<RBDataStruct> RBData;

// Rigid bodies - Buffers
RWStructuredBuffer<float2> RBPositions;
RWStructuredBuffer<float2> RBVelocities;
RWStructuredBuffer<float2> RBProperties; // RBRadii, RBMass

struct RBVectorStruct
{
    float2 Position;
    int ParentRBIndex;
};
RWStructuredBuffer<RBVectorStruct> RBVector;

AppendStructuredBuffer<int3> TraversedChunksAPPEND;
ConsumeStructuredBuffer<int3> TraversedChunksCONSUME;

bool ValidChunk(int ChunkX, int ChunkY)
{
    if (ChunkX >= 0 && ChunkX < ChunkNumW && ChunkY >= 0 && ChunkY < ChunkNumH) {return true;}
    return false;
}

float4 BoundraryCheck(float2 pos, float2 vel, float extraPadding)
{
    float totPadding = BorderPadding + extraPadding;
    float velFactor = 1 - Damping;

    if (pos.y > Height - totPadding)
    {
        vel.y = -abs(vel.y) * velFactor;
        pos.y = Height - totPadding;
    }
    else if (pos.y < totPadding)
    {
        vel.y = abs(vel.y) * velFactor;
        pos.y = totPadding;
    }
    if (pos.x > Width - totPadding)
    {
        vel.x = -abs(vel.x) * velFactor;
        pos.x = Width - totPadding;
    }
    else if (pos.x < totPadding)
    {
        vel.x = abs(vel.x) * velFactor;
        pos.x = totPadding;
    }
    
    return float4(pos.x, pos.y, vel.x, vel.y);
}

[numthreads(ThreadsNum,1,1)]
void RbRbCollisions (uint3 id : SV_DispatchThreadID)
{
    int i = id.x;

    // There may be problems with equal forces, but this code will be revamped when general RB shapes are implemented
    for (int OtherRBIndex = 0; OtherRBIndex < RBodiesNum; OtherRBIndex++)
    {
        if (OtherRBIndex == i) {continue;}

        float2 dst = RBPositions[i] - RBPositions[OtherRBIndex];
        float absDst = length(dst);

        if (absDst >= RBProperties[i].x + RBProperties[OtherRBIndex].x) {continue;}

        float2 diffVel = RBVelocities[OtherRBIndex] - RBVelocities[i];
        float2 normDst = normalize(dst);

        float2 wallDir = float2(normDst.y, -normDst.x);

        // v = (a,b)
        // u = (c,d) (u is normalized)
        // => v':
        // v'_x = (2c^2-1)*a + 2cdb
        // v'_y = 2cda + (2d^2-1)b
        // Mirror vel_diff through normDst
        float a = diffVel.x;
        float b = diffVel.y;
        float c = normDst.x;
        float d = normDst.y;

        float mirrorDiffVelX = (2*c*c-1)*a + 2*c*d*b;
        float mirrorDiffVelY = 2*c*d*a + (2*d*d-1)*b;
        float2 MirrorDiffVel = float2(-mirrorDiffVelX, -mirrorDiffVelY);

        float2 deltaParticleVel = MirrorDiffVel - diffVel;

        float2 exchangedMomentum = deltaParticleVel * RbElasticity;

        // Not currently in use. Also, this is not equal to the energy loss by the collision since temperature_energy is not proportional to vel_energy;
        float overflowMomentum = length(deltaParticleVel * (1 - RbElasticity));

        // v = (a,b)
        // u = (c,d) (u is normalized)
        // => v_projected:
        // v_projected_x = (ac+bd)*c
        // v_projected_y = (ac+bd)*d
        // Momentum and circular impulses:

        // Vector2 centerImpulse = exchangedMomentum [proj to] normDst
        // Vector2 rotation_impulse = exchangedMomentum [proj to] wallDir
        // But these methods are not currently used since, for circular objects, centerImpulse = exchangedMomentum, and, rotation_impulse = 0.
        // Thus:
        float2 centerImpulse = exchangedMomentum;

        RBVelocities[i] -= centerImpulse / (RBProperties[i].y);

        float overlapDst = RBProperties[OtherRBIndex].x + RBProperties[i].x - length(dst);

        RBPositions[i] += overlapDst * normDst / 2;
    }
}

[numthreads(ThreadsNum,1,1)]
void RbParticleCollisions (uint3 id : SV_DispatchThreadID)
{
    int i = id.x;

    RBVelocities[i].y -= Gravity * DeltaTime;
    RBPositions[i] += RBVelocities[i] * DeltaTime;

    float4 PosVelData = BoundraryCheck(RBPositions[i], RBVelocities[i], RBProperties[i].x - 0.5);
    RBPositions[i] = float2(PosVelData.x, PosVelData.y);
    RBVelocities[i] = float2(PosVelData.z, PosVelData.w);
    
    // Int type conversion removes decimals, effectively doing a Floor() operation
    int ChunkX = (int)(RBPositions[i].x / MaxInfluenceRadius);
    int ChunkY = (int)(RBPositions[i].y / MaxInfluenceRadius);

    int searchRadius = (int)(ceil(RBProperties[i].x));

    for (int x = -searchRadius; x <= searchRadius; x++)
    {
        for (int y = -searchRadius; y <= searchRadius; y++)
        {
            int CurChunkX = ChunkX + x;
            int CurChunkY = ChunkY + y;
            
            if (!ValidChunk(CurChunkX, CurChunkY)) {continue;}

            int ChunkKey = CurChunkY * ChunkNumW + CurChunkX;
            int startIndex = StartIndices[ChunkKey];

            int Index = startIndex; 
            while (Index < ParticlesNum && ChunkKey == SpatialLookup[Index].y)
            {
                int particleIndex = SpatialLookup[Index].x;

                float2 dst = PData[particleIndex].Position - RBPositions[i];
                float absDst = length(dst);

                if (absDst < RBProperties[i].x + RbPStickyRadius) 
                {
                    // forces pointing against the rb should be avoided. Instead, only opposing forces should be affected by being lessened
                    PData[particleIndex].Velocity += -normalize(dst) * RbPStickyness * DeltaTime;
                }

                if (absDst >= RBProperties[i].x) {Index += 1; continue;}

                float2 diffVel = PData[particleIndex].Velocity - RBVelocities[i];

                float2 normDst = normalize(dst);
                float2 wallDir = float2(normDst.y, -normDst.x);

                // v = (a,b)
                // u = (c,d) (u is normalized)
                // => v':
                // v'_x = (2c^2-1)*a + 2cdb
                // v'_y = 2cda + (2d^2-1)b
                // Mirror vel_diff through normDst
                float a = diffVel.x;
                float b = diffVel.y;
                float c = normDst.x;
                float d = normDst.y;

                float mirrorDiffVelX = (2*c*c-1)*a + 2*c*d*b;
                float mirrorDiffVelY = 2*c*d*a + (2*d*d-1)*b;
                float2 mirrorDiffVel = float2(-mirrorDiffVelX, -mirrorDiffVelY);

                float2 deltaParticleVel = mirrorDiffVel - diffVel;

                float2 exchangedMomentum = deltaParticleVel * RbElasticity;

                // Not currently in use. Also, this is not equal to the energy loss by the collision since temperature_energy is not proportional to vel_energy;
                float overflowMomentum = length(deltaParticleVel * (1 - RbElasticity));

                // v = (a,b)
                // u = (c,d) (u is normalized)
                // => v_projected:
                // v_projected_x = (ac+bd)*c
                // v_projected_y = (ac+bd)*d
                // Momentum and circular impulses:

                // Vector2 centerImpulse = exchangedMomentum [proj to] normDst
                // Vector2 rotation_impulse = exchangedMomentum [proj to] wallDir
                // But these methods are not currently used since, for circular objects, centerImpulse = exchangedMomentum, and, rotation_impulse = 0.
                // Thus:
                float2 centerImpulse = exchangedMomentum;

                RBVelocities[i] -= centerImpulse / (2 * RBProperties[i].y);

                float2 relCollisionPos = RBProperties[i].x * normDst;
                float2 newParticlePos = RBPositions[i] + relCollisionPos;

                PData[particleIndex].Position = newParticlePos;
                PData[particleIndex].Velocity += exchangedMomentum;

                // Increment Index each iteration - Chunk particle search algorithm
                Index += 1;
            }
        }
    }

    PosVelData = BoundraryCheck(RBPositions[i], RBVelocities[i], RBProperties[i].x - 0.5);
    RBPositions[i] = float2(PosVelData.x, PosVelData.y);
    RBVelocities[i] = float2(PosVelData.z, PosVelData.w);
}

void TraverseLineSegment(float startX, float startY, float endX, float endY, int LineIndex)
{
    // Before imlementing any changes, try them out in MODULETEST3.py first

    if (startX > endX)
    {
        float eX = endX;
        float eY = endY;
        endX = startX;
        endY = startY;
        startX = eX;
        startY = eY;
    }
    float denominator = endX - startX;
    // if dx == 0, skip collision detection for this frame
    if (denominator == 0) {return;}
    float k = (endY - startY) / denominator;
    if (k == 0) {k = 0.0001;}
    int searchHeight = (int)ceil(abs(k)) + 1;
    int xBase = (int)floor(startX) - 1;
    float yBase = (int)floor(startY - k);

    for (int y1 = yBase - 1; y1 < yBase + searchHeight + 1; y1++)
    {
        TraversedChunksAPPEND.Append(int3(xBase, y1, LineIndex));
    }

    float dx = ceil(startX) - startX;
    yBase += dx * k;
    int yBaseUse = (int)floor(yBase);
    xBase += 1;

    for (int y = yBaseUse - 1; y < yBaseUse + searchHeight + 1; y++)
    {
        TraversedChunksAPPEND.Append(int3(xBase, y, LineIndex));
    }

    for (int x = xBase; x <= (int)floor(endX)+2; x++)
    {
        yBase += k;
        yBaseUse = (int)floor(yBase);
        for (int y = yBaseUse - 1; y < yBaseUse + searchHeight + 1; y++)
        {
            TraversedChunksAPPEND.Append(int3(x, y, LineIndex));
        }
    }
}

float2 SignedDistanceToLineSegment(float2 A, float2 B, float2 P)
{
    float2 AB = B - A;
    float2 AP = P - A;
    float ABLengthSquared = dot(AB, AB);

    // Scalar projection
    float AP_dot_AB = dot(AP, AB);
    float t = AP_dot_AB / ABLengthSquared;

    // Clamp t to the closest point on the line segment
    t = clamp(t, 0.0, 1.0);

    // Closest point on line segment to P
    float2 closestPoint = A + t * AB;

    // Return the distance vector from P to the closest point
    return -(P - closestPoint);
}

// Returns true if the line AB crosses the line CD
bool CheckLinesIntersect(float2 A, float2 B, float2 C, float2 D)
{
    return ccw(A, C, D) != ccw(B, C, D) && ccw(A, B, C) != ccw(A, B, D);
}

bool CheckCollision(float2 nextFramePosDisplacement, float2 dstToLine) {
    float uLength = length(dstToLine);
    if (uLength == 0) {
        return false;
    }

    float dotProductVU = dot(nextFramePosDisplacement, dstToLine);
    if (dotProductVU < 0) {
        // Projection is in the opposite direction
        return false;
    }

    float projectionLength = abs(dotProductVU) / uLength;
    return projectionLength > uLength;
}

bool SideOfLine(float2 A, float2 B, float2 dstVec) {
    float2 lineVec = normalize(B - A);

    float crossProduct = cross2d(lineVec, dstVec);

    return crossProduct > 0;  // True if P is on the left side of the line from A to B
}

void ResolveCollision(PDataStruct PData_i, PTypeStruct PType_i, RBDataStruct RBData_i, float2 NormLineVector, int pIndex)
{
    // is wallDir pointing IN or OUT, and does it matter? Is is probably the result of a 90 degree turn a (clockwise or anticlockwise) direction
    float2 perpNormLineVector = float2(NormLineVector.y, -NormLineVector.x);

    // When adding circular motion, this will have to be updated
    float2 RBVel = RBData_i.Velocity;
    float2 diffVel = PData_i.Velocity - RBVel;

    // float2 normDst = normalize(dst); = perpNormLineVector
    // float2 wallDir = float2(normDst.y, -normDst.x);

    // v = (a,b)
    // u = (c,d) (u is normalized)
    // => v':
    // v'_x = (2c^2-1)*a + 2cdb
    // v'_y = 2cda + (2d^2-1)b
    // Mirror vel_diff through normDst
    float a = diffVel.x;
    float b = diffVel.y;
    float c = perpNormLineVector.x;
    float d = perpNormLineVector.y;

    float mirrorDiffVelX = (2*c*c-1)*a + 2*c*d*b;
    float mirrorDiffVelY = 2*c*d*a + (2*d*d-1)*b;
    float2 mirrorDiffVel = float2(-mirrorDiffVelX, -mirrorDiffVelY);

    float2 collisionImpulse = mirrorDiffVel - diffVel;

    float2 exchangedMomentum = collisionImpulse * RbElasticity;

    // Not currently in use. Also, this is not equal to the energy loss by the collision since temperature_energy is not proportional to vel_energy;
    float absOverflowMomentum = length(collisionImpulse * (1 - RbElasticity));

    // v = (a,b)
    // u = (c,d) (u is normalized)
    // => v_projected:
    // v_projected_x = (ac+bd)*c
    // v_projected_y = (ac+bd)*d
    // Momentum and circular impulses:

    // Vector2 centerImpulse = exchangedMomentum [proj to] normDst
    // Vector2 rotation_impulse = exchangedMomentum [proj to] wallDir
    // float2 centerImpulse = exchangedMomentum; // not usable - RB Impulse!!!!!
    // RBVelocities[i] -= centerImpulse / (2 * RBProperties[i].y); // not usable - RB Impulse!!!!!

    // float2 relCollisionPos = RBProperties[i].x * normDst;
    // float2 newParticlePos = RBPositions[i] + relCollisionPos;
    // PData[particleIndex].Position = newParticlePos;

    // PData[pIndex].Velocity += exchangedMomentum * 0.5;
    // PData[pIndex].Velocity = float2(0, 0);
    PData[pIndex].Velocity += exchangedMomentum;

    // Slightly offset the particle from the RB surface to minimize the risk of particles glitching through as very low velocities
    PData[pIndex].Position += perpNormLineVector*0.1;
}

[numthreads(1,1,1)]
void PopulateTraversedChunks (uint3 id : SV_DispatchThreadID)
{
    int i = id.x;

    RBVectorStruct lineVectorA = RBVector[i];
    RBVectorStruct lineVectorB = RBVector[i+1];

    if (lineVectorA.ParentRBIndex != lineVectorB.ParentRBIndex) {return;}

    float2 parentPos = RBData[lineVectorA.ParentRBIndex].Position; // A and B have the same parent
    float2 startPos = (lineVectorA.Position + parentPos) / (float)MaxInfluenceRadius;
    float2 endPos = (lineVectorB.Position + parentPos) / (float)MaxInfluenceRadius;
    TraverseLineSegment(startPos.x, startPos.y, endPos.x, endPos.y, i);
}

[numthreads(1, 1, 1)]
void ConsumeTraversedChunks(uint3 id : SV_DispatchThreadID)
{
    int3 curChunk = TraversedChunksCONSUME.Consume();
    int CurChunkX = curChunk.x;
    int CurChunkY = curChunk.y;
    int LineIndex = curChunk.z;

    // check the default value for data!!!!!
    if (CurChunkX == 0 && CurChunkY == 0 && LineIndex == 0) {return;}
    if (!ValidChunk(CurChunkX, CurChunkY)) {return;}

    int ChunkKey = CurChunkY * ChunkNumW + CurChunkX;
    int startIndex = StartIndices[ChunkKey];

    float2 totRBImpulse = float2(0.0, 0.0);
    int Index = startIndex; 
    while (Index < ParticlesNum && ChunkKey == SpatialLookup[Index].y)
    {
        int pIndex = SpatialLookup[Index].x;
        PDataStruct PData_i = PData[pIndex];
        PTypeStruct PType_i = PTypes[PData_i.PType];

        RBVectorStruct lineVectorA = RBVector[LineIndex];
        RBVectorStruct lineVectorB = RBVector[LineIndex+1];

        RBDataStruct parentRBData = RBData[lineVectorA.ParentRBIndex]; // A and B have the same parent
        float2 dstToLine = SignedDistanceToLineSegment(lineVectorA.Position + parentRBData.Position, lineVectorB.Position + parentRBData.Position, PData_i.Position);
        float2 nextDstToLine = SignedDistanceToLineSegment(lineVectorA.Position + parentRBData.Position, lineVectorB.Position + parentRBData.Position, PData_i.Position + PData_i.Velocity * DeltaTime);

        if (SideOfLine(lineVectorA.Position, lineVectorB.Position, dstToLine) != SideOfLine(lineVectorA.Position, lineVectorB.Position, nextDstToLine) && CheckLinesIntersect(PData_i.Position, PData_i.Position + PData_i.Velocity * DeltaTime, lineVectorA.Position + parentRBData.Position, lineVectorB.Position + parentRBData.Position))
        {
            float2 LineVectorNorm = normalize(RBVector[LineIndex+1].Position - RBVector[LineIndex].Position);
            ResolveCollision(PData_i, PType_i, parentRBData, LineVectorNorm, pIndex);
        }

        // Increment Index each iteration - Chunk particle search algorithm
        Index += 1;
    }

    // Add totRBImpulse to current line's parent RB

    // Could delete other impulse data if they write to the same line at the same time.
    // LineCollisionImpulses[LineIndex] += totRBImpulse;
}