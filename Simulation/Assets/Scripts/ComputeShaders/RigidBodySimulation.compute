#pragma kernel SimulateRB_RB // 0
#pragma kernel SimulateRB_P // 1

#include "DataTypes.hlsl"
#include "Constants.hlsl"
#include "MathResources.hlsl"
#include "CompositionResources.hlsl"

const uint Width;
const uint Height;
const float BorderPadding;

const uint NumRigidBodies;
const uint NumParticles;

// Per-timestep-set constants
const float DeltaTime;

// Particles - Buffers
StructuredBuffer<int2> SpatialLookup; // [ParticlesNum](particleIndex, ChunkKey)
StructuredBuffer<PType> PTypes;
RWStructuredBuffer<PData> PDatas;

RWStructuredBuffer<RigidBody> RigidBodies;
StructuredBuffer<RBVector> RBVectors;

bool IsNearBoundary(float2 pos, float maxRadiusDstSqr)
{
    float maxRadiusDst = sqrt(maxRadiusDstSqr);

    // Check if the rigid body is near any boundary
    return pos.x - maxRadiusDst < BorderPadding  // Near left boundary
        || pos.x + maxRadiusDst > Width - BorderPadding  // Near right boundary
        || pos.y - maxRadiusDst < BorderPadding  // Near bottom boundary
        || pos.y + maxRadiusDst > Height - BorderPadding;  // Near top boundary
}

void GetRBBounds(RigidBody rb, inout float2 boundsMin, inout float2 boundsMax)
{
    uint startIndex = rb.startIndex;
    uint endIndex = rb.endIndex;
    for (uint vecIndex = startIndex; vecIndex < endIndex; vecIndex++)
    {
        float2 localVec = RBVectors[vecIndex].pos + rb.pos;

        rotate(localVec, rb.rot);

        boundsMin = min(boundsMin, localVec);
        boundsMax = max(boundsMax, localVec);
    }
}

[numthreads(TN_RBS1,1,1)]
void SimulateRB_RB (uint3 id : SV_DispatchThreadID)
{
    if (id.x >= NumRigidBodies) return;
    uint i = id.x;

    RigidBody rb = RigidBodies[i];

    // Gravity
    rb.vel -= float2(0, rb.gravity * DeltaTime);

    // Update position & rotation
    rb.pos += rb.vel * DeltaTime;
    rb.rot += rb.rotVel * DeltaTime;

    float bounciness = 0.5;

    // Make sure rigid body is inside simulation bounds
    if (IsNearBoundary(rb.pos, rb.maxRadiusSqr))
    {
        float2 boundsMin = float2(1.#INF, 1.#INF);
        float2 boundsMax = float2(-1.#INF, -1.#INF);
        GetRBBounds(rb, boundsMin, boundsMax);

        // X-axis collision
        if (boundsMin.x < BorderPadding)
        {
            rb.pos.x += BorderPadding - boundsMin.x;
            rb.vel.x = -rb.vel.x * bounciness;
        }
        else if (boundsMax.x > Width - BorderPadding)
        {
            rb.pos.x -= boundsMax.x - (Width - BorderPadding);
            rb.vel.x = -rb.vel.x * bounciness;
        }

        // Y-axis collision
        if (boundsMin.y < BorderPadding)
        {
            rb.pos.y += BorderPadding - boundsMin.y;
            rb.vel.y = -rb.vel.y * bounciness;
        }
        else if (boundsMax.y > Height - BorderPadding)
        {
            rb.pos.y -= boundsMax.y - (Height - BorderPadding);
            rb.vel.y = -rb.vel.y * bounciness;
        }
    }

    RigidBodies[i] = rb;
}

void AddImpulseData(inout ImpulseData a, ImpulseData b, int rbIndex)
{
    if (a.rbIndex == rbIndex)
    {
        a.centerImpulse += b.centerImpulse;
        a.rotImpulse += b.rotImpulse;
    }
    else
    {
        a.centerImpulse = b.centerImpulse;
        a.rotImpulse = b.rotImpulse;
        a.rbIndex = rbIndex;
    }
}

bool RayRBIntersect(float2 pPos, RigidBody rb)
{
    // Keep the last vector stored to avoid unnecessary data fetches
    RBVector lastVec = RBVectors[rb.startIndex];
    float2 rayEnd = float2(1.#INF, pPos.y);

    uint intersections = 0;
    uint startIndex = rb.startIndex;
    uint endIndex = rb.endIndex;
    for (uint vecIndex = startIndex + 1; vecIndex <= endIndex; vecIndex++)
    {
        RBVector newVec = RBVectors[wrapUint(vecIndex, startIndex, endIndex)];

        bool intersects = CheckLinesIntersect(pPos, rayEnd, lastVec.pos + rb.pos, newVec.pos + rb.pos);

        if (intersects) intersections++;

        lastVec = newVec;
    }

    bool isInside = intersections % 2 == 1; // intersections % 2 == 1;

    return isInside;
}

RBHitInfo RayRBIntersectHitInfo(float2 pPos, float2 pDir, RigidBody rb)
{
    // Keep the last vector stored to avoid redundant data fetches
    RBVector lastVec = RBVectors[rb.startIndex];
    RBHitInfo rbHitInfo = InitRBHitInfo();

    float2 rayStart = pPos - pDir * 1000;
    float2 rayEnd = pPos + pDir * 1000;

    float minDstSqr = 1.#INF;
    uint startIndex = rb.startIndex;
    uint endIndex = rb.endIndex;
    for (uint vecIndex = startIndex + 1; vecIndex <= endIndex; vecIndex++)
    {
        RBVector newVec = RBVectors[wrapUint(vecIndex, startIndex, endIndex)];

        bool intersects = CheckLinesIntersect(rayStart, rayEnd, lastVec.pos + rb.pos, newVec.pos + rb.pos);

        if (intersects)
        {
            float2 hitPoint = LineIntersectionPoint(rayStart, rayEnd, lastVec.pos + rb.pos, newVec.pos + rb.pos);
            if (hitPoint.x != 1.#INF && hitPoint.y != 1.#INF)
            {
                float dstSqr = dot2(pPos - hitPoint);
                if (dstSqr < minDstSqr)
                {
                    minDstSqr = dstSqr;
                    rbHitInfo.hitPoint = hitPoint;
                    rbHitInfo.lineVec = newVec.pos - lastVec.pos;
                }
            }
        }

        lastVec = newVec;
    }

    rbHitInfo.dst = minDstSqr == 1.#INF ? 1.#INF : sqrt(minDstSqr);
    rbHitInfo.lineVec = normalize(rbHitInfo.lineVec);

    return rbHitInfo;
}

RBHitInfo RayRBDstHitInfo(float2 pPos, RigidBody rb)
{
    // Keep the last vector stored to avoid redundant data fetches
    RBVector lastVec = RBVectors[rb.startIndex];
    RBHitInfo rbHitInfo = InitRBHitInfo();

    float minDstSqr = 1.#INF;
    uint startIndex = rb.startIndex;
    uint endIndex = rb.endIndex;
    for (uint vecIndex = startIndex + 1; vecIndex <= endIndex; vecIndex++)
    {
        RBVector newVec = RBVectors[wrapUint(vecIndex, startIndex, endIndex)];

        float2 dst = DstToLineSegment(lastVec.pos + rb.pos, newVec.pos + rb.pos, pPos);

        float dstSqr = dot2(dst);
        if (dstSqr < minDstSqr)
        {
            minDstSqr = dstSqr;
            rbHitInfo.hitPoint = pPos + dst;
            rbHitInfo.lineVec = newVec.pos - lastVec.pos;
        }

        lastVec = newVec;
    }

    rbHitInfo.dst = minDstSqr == 1.#INF ? 1.#INF : sqrt(minDstSqr);
    rbHitInfo.lineVec = normalize(rbHitInfo.lineVec);

    return rbHitInfo;
}

void SetPosWithSafeGuards(inout float2 pos, float2 newPos, float2 vec)
{
    float diffThreshold = 1.0;

    float sqrDst = dot2(newPos - pos);
    if (sqrDst < diffThreshold)
    {
        float2 epsilonOffset = vec * 0.1;
        pos = newPos + epsilonOffset;
    }
}

float3 ResolveCollisionAdvanced(inout PData pData, RigidBody rb)
{
    EnsureNonZero(pData.Velocity);

    RBHitInfo rbHitInfo = RayRBDstHitInfo(pData.pos, rb);

    float2 perpNormLineVec = float2(rbHitInfo.lineVec.y, -rbHitInfo.lineVec.x);

    // Relative velocity between the particle and the rigid body
    float2 diffVel = pData.Velocity - rb.vel;
    float2 mirrorDiffVel = reflect(diffVel, perpNormLineVec);

    float2 impulse = (mirrorDiffVel - diffVel) * rb.elasticity;

    // Update the particle's velocity
    pData.Velocity += impulse; // / pData.mass

    float2 collisionPoint = rotate(rbHitInfo.hitPoint, rb.rotVel * DeltaTime);
    SetPosWithSafeGuards(pData.pos, collisionPoint, perpNormLineVec);

    // Normalized relative collision position
    float2 relCollPos = collisionPoint - rb.pos;
    float2 normRelCollPos = relCollPos.x > EPSILON && relCollPos.y > EPSILON ? normalize(relCollPos) : float2(0, 0);

    // Perpendicular to the normalized relative collision position
    float2 perpNormLocalCollissionPos = float2(normRelCollPos.y, -normRelCollPos.x);

    float2 centerImpulse = dot(normRelCollPos, -impulse) * normRelCollPos;
    float rotImpulse = dot(-perpNormLocalCollissionPos, -impulse);

    return float3(centerImpulse.x, centerImpulse.y, rotImpulse);
}

float3 ResolveCollisionSimple(inout PData pData, RigidBody rb)
{
    RBHitInfo rbHitInfo = RayRBDstHitInfo(pData.pos, rb);

    float2 perpNormLineVec = float2(rbHitInfo.lineVec.y, -rbHitInfo.lineVec.x);

    // Relative velocity between the particle and the rigid body
    float2 relPos = pData.Velocity - rb.vel;
    float2 mirrorRelPos = reflect(relPos, perpNormLineVec);

    float2 newPVel = mirrorRelPos * rb.elasticity;
    float2 velDiff = newPVel - pData.Velocity;
    float2 impulse = velDiff;

    // Update the particle's velocity
    pData.Velocity = newPVel; // / pData.mass

    float2 collisionPoint = rotate(rbHitInfo.hitPoint, rb.rotVel * DeltaTime);
    SetPosWithSafeGuards(pData.pos, collisionPoint, perpNormLineVec);

    // Normalized relative collision position
    float2 relCollPos = collisionPoint - rb.pos;
    float2 normRelCollPos = relCollPos.x > EPSILON && relCollPos.y > EPSILON ? normalize(relCollPos) : float2(0, 0);

    // Perpendicular to the normalized relative collision position
    float2 perpNormLocalCollissionPos = float2(normRelCollPos.y, -normRelCollPos.x);

    float2 centerImpulse = dot(normRelCollPos, -impulse) * normRelCollPos;
    float rotImpulse = dot(-perpNormLocalCollissionPos, -impulse);

    return float3(centerImpulse.x, centerImpulse.y, rotImpulse);
}

groupshared bool anyCollisionInGroup;
groupshared ImpulseData rbImpulses[TN_RBS2];
[numthreads(TN_RBS2,1,1)]
void SimulateRB_P (uint3 id : SV_DispatchThreadID, uint3 groupID : SV_GroupID, uint3 groupThreadID : SV_GroupThreadID)
{
    if (id.x >= NumParticles) return;
    uint groupIndex = id.x % TN_RBS2;
    rbImpulses[groupIndex] = InitImpulseData(0, -1);

    uint pIndex = SpatialLookup[id.x].x;
    PData pData = PDatas[pIndex];

    for (int rbIndex = 0; rbIndex < (int)NumRigidBodies; rbIndex++)
    {
        if (groupIndex == 0) anyCollisionInGroup = false;

        GroupMemoryBarrierWithGroupSync();

        RigidBody rb = RigidBodies[rbIndex];

        // Check P_RB collision
        if (dot2(rb.pos - pData.pos) <= rb.maxRadiusSqr)
        {
            bool isInside = RayRBIntersect(pData.pos, rb);

            if (isInside)
            {
                float3 combinedImpulse = ResolveCollisionSimple(pData, rb);
                rbImpulses[groupIndex] = InitImpulseData(combinedImpulse, rbIndex);
                anyCollisionInGroup = true;
            }
        }

        GroupMemoryBarrierWithGroupSync();

        // Sum up all rb impulses from the local thread group
        if (anyCollisionInGroup)
        {
            // Sum up group shared values
            for (uint offset = TN_RBS2 / 2; offset > 0; offset /= 2)
            {
                GroupMemoryBarrierWithGroupSync();

                if (groupIndex < offset && groupIndex + offset < TN_RBS2)
                {
                    ImpulseData highImpulseData = rbImpulses[groupIndex + offset];
                    if (highImpulseData.rbIndex == rbIndex)
                    {
                        AddImpulseData(rbImpulses[groupIndex], highImpulseData, rbIndex);
                    }
                }
            }

            GroupMemoryBarrierWithGroupSync();
            
            // Atomically add to rb
            if (groupIndex == 0)
            {
                ImpulseData totImpulseData = rbImpulses[groupIndex];

                if (totImpulseData.rbIndex == rbIndex)
                {
                    // // Atomically add to linear velocity
                    // InterlockedAdd(RigidBodies[rbIndex].vel.x, totImpulseData.centerImpulse.x);
                    // InterlockedAdd(RigidBodies[rbIndex].vel.y, totImpulseData.centerImpulse.y);

                    // // Atomically add to rotational velocity
                    // InterlockedAdd(RigidBodies[rbIndex].rotVel, totImpulseData.rotImpulse);
                }
            }
        }

        GroupMemoryBarrierWithGroupSync();
    }

    PDatas[pIndex] = pData;
}