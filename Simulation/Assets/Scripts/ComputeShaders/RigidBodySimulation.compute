#pragma kernel ApplyLocalAngularRotation
#pragma kernel PopulateTraversedChunks
#pragma kernel ResolveLineCollisions
#pragma kernel RBForces

#include "MathResources.hlsl"

static const int ThreadsNum = 1;

// Constants
const int ChunkNumW;
const int ChunkNumH;
const int Width;
const int Height;
const int ParticlesNum;
const int RBodiesNum;
const int MaxInfluenceRadius;
const int MaxChunkSearchSafety;

const float Damping;
// const float Viscocity;
const float Gravity;
const float RbElasticity;
const float BorderPadding;

// Per-timestep-set constants
const float DeltaTime;

// Particles - Buffers
RWStructuredBuffer<int2> SpatialLookup; // [ParticlesNum](particleIndex, ChunkKey)
RWStructuredBuffer<int> StartIndices;

struct PTypeStruct
{
    float TargetDensity;
    int MaxInfluenceRadius;
    float Pressure;
    float NearPressure;
    float Damping;
    float Viscocity;
    float Elasticity;
    float Plasticity;
    float Stickyness;
    float Gravity;
    float colorG;
};
RWStructuredBuffer<PTypeStruct> PTypes;

struct PDataStruct
{
    float2 PredPosition;
    float2 Position;
    float2 Velocity;
    float2 LastVelocity;
    float Density;
    float NearDensity;
    float2 StickyLineDst;
    float StickyLineDstSqr;
    int StickyLineIndex;
    int PType;
};
RWStructuredBuffer<PDataStruct> PData;

struct RBDataStruct
{
    float2 Position;
    float2 Velocity;
    // radians / second
    float AngularImpulse;
    float Stickyness;
    float StickynessRange;
    float StickynessRangeSqr;
    float2 NextPos;
    float2 NextVel;
    float NextAngImpulse;
    float Mass;
    int2 LineIndices;
    float MaxDstSqr;
    int WallCollision;
    int Stationary; // 1 -> Stationary, 0 -> Non-stationary
};
RWStructuredBuffer<RBDataStruct> RBData;

struct RBVectorStruct
{
    float2 Position;
    float2 LocalPosition;
    float3 ParentImpulse;
    int ParentRBIndex;
    int WallCollision;
};
RWStructuredBuffer<RBVectorStruct> RBVector;

AppendStructuredBuffer<int3> TraversedChunksAPPEND;
ConsumeStructuredBuffer<int3> TraversedChunksCONSUME;

bool ValidChunk(int ChunkX, int ChunkY)
{
    if (ChunkX >= 0 && ChunkX < ChunkNumW && ChunkY >= 0 && ChunkY < ChunkNumH) {return true;}
    return false;
}

bool RBBoundraryCheck(float2 Point, float extraPadding)
{
    if (Point.x > BorderPadding+extraPadding && Point.x < Width-BorderPadding-extraPadding && Point.y > BorderPadding+extraPadding && Point.y < Height-BorderPadding-extraPadding) { return true; }
    return false;
}

void RBBoundraryCollision(float2 pos, int RBIndex, float extraPadding, float Damping)
{
    float totPadding = BorderPadding + extraPadding;
    float velFactor = 1 - Damping;

    if (pos.y > Height - totPadding)
    {
        RBData[RBIndex].NextVel.y = -abs(RBData[RBIndex].NextVel.y) * velFactor;
        RBData[RBIndex].NextPos.y -= pos.y - (Height - totPadding);
    }
    else if (pos.y < totPadding)
    {
        RBData[RBIndex].NextVel.y = abs(RBData[RBIndex].NextVel.y) * velFactor;
        RBData[RBIndex].NextPos.y += totPadding - pos.y;
    }
    if (pos.x > Width - totPadding)
    {
        RBData[RBIndex].NextVel.x = -abs(RBData[RBIndex].NextVel.x) * velFactor;
        RBData[RBIndex].NextPos.x -= pos.x - (Width - totPadding);
    }
    else if (pos.x < totPadding)
    {
        RBData[RBIndex].NextVel.x = abs(RBData[RBIndex].NextVel.x) * velFactor;
        RBData[RBIndex].NextPos.x += totPadding - pos.x;
    }
}

void TraverseLineSegment(float startX, float startY, float endX, float endY, int LineIndex, int Margin) {
    bool steep = abs(endY - startY) > abs(endX - startX);

    if (steep) {
        // Swap X and Y
        float temp = startX;
        startX = startY;
        startY = temp;
        temp = endX;
        endX = endY;
        endY = temp;
    }

    if (startX > endX) {
        // Swap start and end points
        float tempX = startX;
        float tempY = startY;
        startX = endX;
        startY = endY;
        endX = tempX;
        endY = tempY;
    }

    float dx = endX - startX;
    float dy = abs(endY - startY);
    float error = dx / 2.0f;
    float ystep = (startY < endY) ? 1 : -1;
    float y = startY;

    for (float x = startX; x <= endX; x++) {
        for (int mx = -Margin; mx <= Margin; mx++) {
            for (int my = -Margin; my <= Margin; my++) {
                int3 cell = steep ? int3(y + my, x + mx, LineIndex) : int3(x + mx, y + my, LineIndex);
                TraversedChunksAPPEND.Append(cell);
            }
        }

        error -= dy;
        if (error < 0) {
            y += ystep;
            error += dx;
        }
    }
}

bool CheckCollision(float2 nextFramePosDisplacement, float2 dstToLine) {
    float uLength = length(dstToLine);
    if (uLength == 0) {
        return false;
    }

    float dotProductVU = dot(nextFramePosDisplacement, dstToLine);
    if (dotProductVU < 0) {
        // Projection is in the opposite direction
        return false;
    }

    float projectionLength = abs(dotProductVU) / uLength;
    return projectionLength > uLength;
}

void AddRBPStickyness(float absDstToLineSqr, float2 dstToLine, int pIndex, int lineIndex, RBDataStruct RBData_i)
{
    // StickynessRange should stay smaller than ~chunksearchDst to avoid visual artifacts
    if (absDstToLineSqr >= RBData_i.StickynessRangeSqr) { return; }
    // otherDstToLineSqr is 0 if a lineIndex has yet to be assigned
    // otherLine is -1 if a lineIndex is yet to be assigned
    float absDstToOtherLineSqr = PData[pIndex].StickyLineDstSqr;
    if (absDstToLineSqr >= absDstToOtherLineSqr && PData[pIndex].StickyLineIndex != -1) { return; }

    PData[pIndex].StickyLineIndex = lineIndex;
    PData[pIndex].StickyLineDst = dstToLine;
    PData[pIndex].StickyLineDstSqr = absDstToLineSqr;
}

float3 ResolveCollision(PDataStruct PData_i, PTypeStruct PType_i, RBDataStruct parentRBData, float2 NormLineVector, int pIndex, float2 NextPosChange, float2 NextVel, float NextAngImpulse)
{
    // is wallDir pointing IN or OUT, and does it matter? Is is probably the result of a 90 degree turn a (clockwise or anticlockwise) direction
    float2 perpNormLineVector = float2(NormLineVector.y, -NormLineVector.x);

    // When adding circular motion, this will have to be updated
    float2 RBVel = NextVel;
    float2 diffVel = PData_i.Velocity - RBVel;

    // float2 normDst = normalize(dst); = perpNormLineVector
    // float2 wallDir = float2(normDst.y, -normDst.x);

    // v = (a,b)
    // u = (c,d) (u is normalized)
    // => v':
    // v'_x = (2c^2-1)*a + 2cdb
    // v'_y = 2cda + (2d^2-1)b
    // Mirror vel_diff through normDst
    float a = diffVel.x;
    float b = diffVel.y;
    float c = perpNormLineVector.x;
    float d = perpNormLineVector.y;

    float mirrorDiffVelX = (2*c*c-1)*a + 2*c*d*b;
    float mirrorDiffVelY = 2*c*d*a + (2*d*d-1)*b;
    float2 mirrorDiffVel = float2(-mirrorDiffVelX, -mirrorDiffVelY);

    float2 collisionImpulse = mirrorDiffVel - diffVel;

    float2 exchangedMomentum = collisionImpulse * RbElasticity;

    // Not currently in use. Also, this is not equal to the energy loss by the collision since temperature_energy is not proportional to vel_energy;
    // float absOverflowMomentum = length(collisionImpulse * (1 - RbElasticity));

    // v = (a,b)
    // u = (c,d) (u is normalized)
    // => v_projected:
    // v_projected_x = (ac+bd)*c
    // v_projected_y = (ac+bd)*d
    // Momentum and circular impulses:

    // Vector2 centerImpulse = exchangedMomentum [proj to] normDst
    // Vector2 rotation_impulse = exchangedMomentum [proj to] wallDir
    // float2 centerImpulse = exchangedMomentum; // not usable - RB Impulse!!!!!
    // RBVelocities[i] -= centerImpulse / (2 * RBProperties[i].y); // not usable - RB Impulse!!!!!

    // float2 relCollisionPos = RBProperties[i].x * normDst;
    // float2 newParticlePos = RBPositions[i] + relCollisionPos;
    // PData[particleIndex].Position = newParticlePos;

    // PData[pIndex].Velocity += exchangedMomentum * 0.5;
    // PData[pIndex].Velocity = float2(0, 0);
    PData[pIndex].Velocity += exchangedMomentum;
    // Slightly offset the particle from the RB surface to minimize the risk of particles glitching through as very low velocities
    PData[pIndex].Position = rotate2d(((PData[pIndex].Position + NextPosChange + 0.05*perpNormLineVector) - parentRBData.Position), NextAngImpulse) + parentRBData.Position + 0.05*perpNormLineVector;

    // RB Impulse calculations
    float2 RBtotImpulse = -exchangedMomentum;
    // Collision position can be approximated to PData_i.Position
    float2 collPos = PData_i.Position;
    float2 normRelCollPos = normalize(collPos - parentRBData.Position);
    float2 perpnormRelCollPos = float2(normRelCollPos.y, -normRelCollPos.x);

    float2 centerImpulse = dot(normRelCollPos, RBtotImpulse) * normRelCollPos;

    float rotaryImpulse = dot(-perpnormRelCollPos, RBtotImpulse);

    return float3(centerImpulse.x, centerImpulse.y, rotaryImpulse);
}

[numthreads(ThreadsNum,1,1)]
void ApplyLocalAngularRotation (uint3 id : SV_DispatchThreadID)
{
    int i = id.x;

    RBVectorStruct lineVector = RBVector[i];

    float rotationAngle = RBData[lineVector.ParentRBIndex].AngularImpulse;
    if (rotationAngle == 0) {return;}
    RBVector[i].Position = rotate2d(RBVector[i].Position, rotationAngle);
}

[numthreads(ThreadsNum,1,1)]
void PopulateTraversedChunks (uint3 id : SV_DispatchThreadID)
{
    int i = id.x;

    RBVectorStruct lineVectorA = RBVector[i];
    RBVectorStruct lineVectorB = RBVector[i+1];

    if (lineVectorA.ParentRBIndex != lineVectorB.ParentRBIndex) { return; }

    float2 parentPos = RBData[lineVectorA.ParentRBIndex].Position; // A and B have the same parent
    float2 startWorldPos = lineVectorA.Position + parentPos;
    float2 endWorldPos = lineVectorB.Position + parentPos;
    float2 startChunkPos = startWorldPos / (float)MaxInfluenceRadius;
    float2 endChunkPos = endWorldPos / (float)MaxInfluenceRadius;
    if (!RBBoundraryCheck(startWorldPos, 0))
    {
        RBVector[i].WallCollision = 1;
        int ogv;
        InterlockedAdd(RBData[lineVectorA.ParentRBIndex].WallCollision, 1, ogv);
    }
    TraverseLineSegment(startChunkPos.x, startChunkPos.y, endChunkPos.x, endChunkPos.y, i, MaxChunkSearchSafety);
}

[numthreads(ThreadsNum, 1, 1)]
void ResolveLineCollisions(uint3 id : SV_DispatchThreadID)
{
    int3 curChunk = TraversedChunksCONSUME.Consume();
    int CurChunkX = curChunk.x;
    int CurChunkY = curChunk.y;
    int LineIndex = curChunk.z;

    RBVectorStruct lineVectorA = RBVector[LineIndex];
    RBVectorStruct lineVectorB = RBVector[LineIndex+1];
    RBDataStruct parentRBData = RBData[lineVectorA.ParentRBIndex]; // A and B have the same parent
    
    float2 NextPos = parentRBData.NextPos;
    float2 NextPosChange = NextPos - parentRBData.Position;
    float2 NextVel = parentRBData.NextVel;
    float NextAngImpulse = parentRBData.NextAngImpulse;

    // check the default value for data!!!!!
    if (CurChunkX == 0 && CurChunkY == 0 && LineIndex == 0) {return;}
    if (!ValidChunk(CurChunkX, CurChunkY)) {return;}

    int ChunkKey = CurChunkY * ChunkNumW + CurChunkX;
    int startIndex = StartIndices[ChunkKey];

    // centerImpulse, rotaryImpulse
    float3 totLineImpulse = float3(0.0, 0.0, 0.0);
    int Index = startIndex; 
    while (Index < ParticlesNum && ChunkKey == SpatialLookup[Index].y)
    {
        int pIndex = SpatialLookup[Index].x;

        PDataStruct PData_i = PData[pIndex];
        PTypeStruct PType_i = PTypes[PData_i.PType];

        float2 A = PData_i.Position;
        float2 B = rotate2d(((PData_i.Position + PData_i.Velocity * DeltaTime - NextPosChange) - parentRBData.Position), -NextAngImpulse) + parentRBData.Position;
        float2 C = lineVectorA.Position + parentRBData.Position;
        float2 D = lineVectorB.Position + parentRBData.Position;

        float2 dstToLine = dstToLineSegment(C, D, A);
        float absDstToLineSqr = dot(dstToLine, dstToLine);
        AddRBPStickyness(absDstToLineSqr, dstToLine, pIndex, LineIndex, parentRBData);

        if (CheckLinesIntersect(A, B, C, D))
        {
            // Particle velocity is currently reflecting off of last-frame line position!
            float2 LineVectorNorm = normalize(RBVector[LineIndex+1].Position - RBVector[LineIndex].Position);
            totLineImpulse += ResolveCollision(PData_i, PType_i, parentRBData, LineVectorNorm, pIndex, NextPosChange, NextVel, NextAngImpulse);
        }

        // Increment Index each iteration - Chunk particle search algorithm
        Index += 1;
    }

    // Add totLineImpulse to current line's parent RB
    RBVector[LineIndex].ParentImpulse = totLineImpulse;

    // Could delete other impulse data if they write to the same line at the same time.
    // LineCollisionImpulses[LineIndex] += totLineImpulse;
}

float3 RBImpulse(RBDataStruct RBData_i)
{
    int startIndex = RBData_i.LineIndices.x;
    int endIndex = RBData_i.LineIndices.y;
    float3 totRBImpulse = float3(0.0, 0.0, 0.0);
    for (int lineIndex = startIndex; lineIndex < endIndex; lineIndex++)
    {
        totRBImpulse += RBVector[lineIndex].ParentImpulse;
    }
    return totRBImpulse;
}

[numthreads(ThreadsNum, 1, 1)]
void RBForces(uint3 id : SV_DispatchThreadID)
{
    int i = id.x;

    RBDataStruct RBData_i = RBData[i];
    if (RBData_i.Stationary) { return; }

    float3 totRBImpulse = RBImpulse(RBData_i);

    RBData[i].Velocity = RBData[i].NextVel;
    RBData[i].AngularImpulse = RBData[i].NextAngImpulse;
    RBData[i].Position = RBData[i].NextPos;

    // // Temporary!
    // if (RBData[i].NextAngImpulse == 3.14) {
    //     RBData[i].NextAngImpulse = 0;
    // }

    // RBData[i].NextAngImpulse += totRBImpulse.z * 0.0001 / RBData_i.Mass;
    // RBData[i].NextAngImpulse = 0.05 * DeltaTime;

    RBData[i].NextPos += RBData[i].Velocity * DeltaTime;
    RBData[i].NextVel += float2(totRBImpulse.x, totRBImpulse.y) / RBData[i].Mass;
    RBData[i].NextVel.y -= Gravity * 0.15 * DeltaTime;

    int startIndex = RBData_i.LineIndices.x;
    int endIndex = RBData_i.LineIndices.y;
    if (RBData_i.WallCollision)
    {
        int WallCollisions = RBData_i.WallCollision;
        RBData[i].WallCollision = 0;
        for (int lineIndex = startIndex; lineIndex < endIndex; lineIndex++)
        {
            if (RBVector[lineIndex].WallCollision)
            {
                float2 collPoint = RBData[i].Position + RBVector[lineIndex].Position;
                RBBoundraryCollision(collPoint, i, 0, 0.3);

                WallCollisions--;
                if (WallCollisions == 0) { break; }
            }
        }
    }
}