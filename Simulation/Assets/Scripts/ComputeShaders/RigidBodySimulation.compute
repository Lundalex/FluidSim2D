#pragma kernel SimulateRB_P // 0
#pragma kernel UpdateRBVertices // 1
#pragma kernel SimulateRB_RB // 2
#pragma kernel SimulateRBSprings // 3
#pragma kernel UpdateRigidBodies // 4
#pragma kernel AdjustRBDatas // 5

#include "DataTypes.hlsl"
#include "Constants.hlsl"
#include "MathResources.hlsl"
#include "Composition.hlsl"

// Boundrary settings
const uint2 BoundaryDims;
const float RigidBodyPadding;

// Num variables
const uint NumRigidBodies;
const uint NumVectors;
const uint NumParticles;

// Collision solver settings
const float RB_RBCollisionCorrectionFactor;
const float RB_RBCollisionSlop;

// Interation settings
const float RB_MaxInteractionRadius;
const float RB_InteractionAttractionPower;

// User Interaction
const float2 MousePos;
const bool RMousePressed;
const bool LMousePressed;

// Per-timestep-set constants
const float DeltaTime;

// Particles - Buffers
StructuredBuffer<int2> SpatialLookup; // [ParticlesNum](particleIndex, ChunkKey)
StructuredBuffer<PType> PTypes;
RWStructuredBuffer<PData> PDatas;

RWStructuredBuffer<RigidBody> RigidBodies;
RWStructuredBuffer<RBVector> RBVectors;
RWStructuredBuffer<RBAdjustment> RBAdjustments;

[numthreads(TN_RBS1,1,1)]
void UpdateRBVertices(uint3 id : SV_DispatchThreadID)
{
    if (id.x >= NumVectors) return;
    uint i = id.x;

    RBVector rbVector = RBVectors[i];

    float deltaRot = IntToFloat(RigidBodies[rbVector.parentIndex].rotVel_AsInt) * DeltaTime;

    RBVectors[i].pos = rotate(rbVector.pos, deltaRot);
}

bool IsPointInsideRB(float2 pos, RigidBody rb)
{
    uint intersections = 0;
    uint startIndex = rb.startIndex;
    uint endIndex = rb.endIndex;
    uint numVertices = endIndex - startIndex + 1;

    float2 lastVec = RBVectors[startIndex].pos;
    for (uint i = 0; i < numVertices; i++)
    {
        uint vecIndex = wrapUint(startIndex + i, startIndex, endIndex);
        float2 newVec = RBVectors[vecIndex].pos;

        // Check if the edge from lastVec to newVec intersects the horizontal ray to the right of pos
        if (IsPointToTheLeftOfLine(pos, lastVec + rb.pos, newVec + rb.pos)) intersections++;

        lastVec = newVec;
    }

    // The point is inside the polygon if the number of intersections is odd
    bool isInside = (intersections % 2) == 1;

    return isInside;
}

RBHitInfo RayRBDstHitInfo(float2 pos, RigidBody rb)
{
    // Keep the last vector stored to avoid redundant data fetches
    RBVector lastVec = RBVectors[rb.startIndex];
    RBHitInfo rbHitInfo = InitRBHitInfo();

    float minDstSqr = 1.#INF;
    uint startIndex = rb.startIndex;
    uint endIndex = rb.endIndex;
    for (uint vecIndex = startIndex + 1; vecIndex <= endIndex; vecIndex++)
    {
        RBVector newVec = RBVectors[wrapUint(vecIndex, startIndex, endIndex)];

        float2 dst = DstToLineSegment(lastVec.pos + rb.pos, newVec.pos + rb.pos, pos);

        float dstSqr = dot2(dst);
        if (dstSqr < minDstSqr)
        {
            minDstSqr = dstSqr;
            rbHitInfo.hitPoint = pos + dst;
            rbHitInfo.pointPos = pos;
            rbHitInfo.lineVec = newVec.pos - lastVec.pos;
        }

        lastVec = newVec;
    }

    rbHitInfo.dst = minDstSqr == 1.#INF ? 1.#INF : sqrt(minDstSqr);
    rbHitInfo.lineVec = normalize(rbHitInfo.lineVec);

    return rbHitInfo;
}

// Main Collision Resolution Function
void ResolveCollisionRB_RB(inout RigidBody rbA, inout RigidBody rbB, RBHitInfo rbHitInfo, bool AInsideB_BInsideA,
                           out float2 deltaVelA, out float deltaRotVelA, out float2 deltaVelB, out float deltaRotVelB)
{
    // Initialize output parameters
    deltaVelA = 0;
    deltaRotVelA = 0;
    deltaVelB = 0;
    deltaRotVelB = 0;

    bool canMoveA = rbA.mass > 0;
    bool canMoveB = rbB.mass > 0;
    bool canRotateA = rbA.inertia > 0;
    bool canRotateB = rbB.inertia > 0;

    // Collision point on the rigid body
    float2 collisionPoint = rbHitInfo.hitPoint;

    // Penetration vector: from rbA to rbB or vice versa based on AInsideB_BInsideA
    float2 penetration = AInsideB_BInsideA ? (collisionPoint - rbHitInfo.pointPos) : (rbHitInfo.pointPos - collisionPoint);

    // Compute collision normal based on penetration vector
    float penetrationDepth = length(penetration);
    if (penetrationDepth <= 0.0) return; // No penetration to resolve

    float2 normal = normalize(penetration);

    // Compute inverse masses
    float invMassA = (rbA.mass > 0) ? 1.0 / rbA.mass : 0;
    float invMassB = (rbB.mass > 0) ? 1.0 / rbB.mass : 0;
    float totalInvMass = invMassA + invMassB;

    // Avoid division by zero, which occurs when both rigid bodies are flagged as stationary
    if (totalInvMass == 0) return;

    // Compute the amount of penetration to correct
    float penetrationToCorrect = max(penetrationDepth - RB_RBCollisionSlop, 0.0);
    float2 correction = (penetrationToCorrect / totalInvMass) * RB_RBCollisionCorrectionFactor * normal;

    // Apply positional correction
    if (AInsideB_BInsideA && canMoveA) rbA.pos -= correction * invMassA; // Push rbA out
    if (!AInsideB_BInsideA && canMoveB) rbB.pos += correction * invMassB; // Push rbB out

    // Recompute relative positions after positional correction
    float2 rA = collisionPoint - rbA.pos;
    float2 rB = rbHitInfo.pointPos - rbB.pos;

    // Compute velocities at the point of collision, including rotational velocities
    float2 rbARotVelAtCollisionPoint = crossZ(IntToFloat(rbA.rotVel_AsInt), rA);
    float2 rbBRotVelAtCollisionPoint = crossZ(IntToFloat(rbB.rotVel_AsInt), rB);
    float2 rbAVel = Int2ToFloat2(rbA.vel_AsInt2) + rbARotVelAtCollisionPoint;
    float2 rbBVel = Int2ToFloat2(rbB.vel_AsInt2) + rbBRotVelAtCollisionPoint;

    // Relative velocity
    float2 relVel = rbBVel - rbAVel;

    // Relative velocity along the normal
    float relVelAlongNormal = dot(relVel, normal);

    // Proceed only if the bodies are moving towards each other
    if (relVelAlongNormal >= 0.0) return;

    // Coefficient of restitution (elasticity)
    float e = min(rbA.elasticity, rbB.elasticity);

    // Compute inverse inertias
    float invInertiaA = (rbA.inertia > 0) ? 1.0 / rbA.inertia : 0;
    float invInertiaB = (rbB.inertia > 0) ? 1.0 / rbB.inertia : 0;

    // Compute impulse scalar
    float rACrossN = cross2D(rA, normal);
    float rBCrossN = cross2D(rB, normal);

    float denom = totalInvMass + (rACrossN * rACrossN) * invInertiaA + (rBCrossN * rBCrossN) * invInertiaB;

    // Avoid division by zero
    if (denom == 0) return;

    float j = -(1 + e) * relVelAlongNormal / denom;

    // Compute impulse vector
    float2 impulse = j * normal;

    // Compute delta velocities
    if (canMoveA) deltaVelA += -impulse * invMassA;
    if (canMoveB) deltaVelB += impulse * invMassB;

    if (!canRotateA && !canRotateB) return;

    // Compute delta angular velocities
    float torqueA = cross2D(rA, -impulse);
    float torqueB = cross2D(rB, impulse);

    if (canRotateA) deltaRotVelA += torqueA * invInertiaA;
    if (canRotateB) deltaRotVelB += torqueB * invInertiaB;
}

[numthreads(TN_RBS2,1,1)]
void SimulateRB_RB(uint3 id : SV_DispatchThreadID)
{
    if (id.x >= NumRigidBodies) return;
    uint rbAIndex = id.x;
    RigidBody baseRB = RigidBodies[rbAIndex];

    for (uint rbBIndex = rbAIndex + 1; rbBIndex < MAX_RIGIDBODIES_NUM; rbBIndex++)
    {
        if (rbBIndex >= NumRigidBodies) return;

        RigidBody rbA = baseRB;
        RigidBody rbB = RigidBodies[rbBIndex];
        
        // Don't allow collision checks for rigid bodies linked by a rigid constraint
        bool rigidConstraint = ((int)rbAIndex == rbB.linkedRBIndex && rbB.springStiffness == 0) || ((int)rbBIndex == rbA.linkedRBIndex && rbA.springStiffness == 0);
        
        // Exit early if both rigid bodies are flagged as stationary, or rigidConstraint == true
        if ((rbA.mass == 0 && rbB.mass == 0 && rbA.inertia == 0 && rbB.inertia == 0) || rigidConstraint) return;

        // Record initial positions
        float2 posRecA = rbA.pos;
        float2 posRecB = rbB.pos;
        
        // Early exit if thr two rigid bodies are to far away from each other
        float dst = length(rbB.pos - rbA.pos);
        float radiusSum = sqrt(rbA.maxRadiusSqr) + sqrt(rbB.maxRadiusSqr);
        if (dst > radiusSum) continue;
        
        // Initialize collision data
        RBHitInfo rbHitInfo = InitRBHitInfo();
        bool collisionDetected = false;

        float2 deltaVelA = 0; float2 deltaVelB = 0;
        float deltaRotVelA = 0; float deltaRotVelB = 0;

        // Check if any points of rbA is inside rbB
        uint startIndexA = rbA.startIndex;
        uint endIndexA = rbA.endIndex;
        for (uint vecIndex = startIndexA; vecIndex < endIndexA; vecIndex++)
        {
            float2 vertexA = RBVectors[vecIndex].pos + rbA.pos;

            bool isInside = IsPointInsideRB(vertexA, rbB);
            if (!isInside) continue;

            rbHitInfo = RayRBDstHitInfo(vertexA, rbB);
            collisionDetected = true;
            bool AInsideB_BInsideA = false;

            // Resolve collision and get delta impulses
            ResolveCollisionRB_RB(rbA, rbB, rbHitInfo, AInsideB_BInsideA, deltaVelA, deltaRotVelA, deltaVelB, deltaRotVelB);
        }

        // Check if any points of rbB is inside rbA
        uint startIndexB = rbB.startIndex;
        uint endIndexB = rbB.endIndex;
        for (vecIndex = startIndexB; vecIndex < endIndexB; vecIndex++)
        {
            float2 vertexB = RBVectors[vecIndex].pos + rbB.pos;

            bool isInside = IsPointInsideRB(vertexB, rbA);
            if (!isInside) continue;

            rbHitInfo = RayRBDstHitInfo(vertexB, rbA);
            collisionDetected = true;
            bool AInsideB_BInsideA = true;

            // Resolve collision and get delta impulses
            ResolveCollisionRB_RB(rbA, rbB, rbHitInfo, AInsideB_BInsideA, deltaVelA, deltaRotVelA, deltaVelB, deltaRotVelB);
        }

        if (collisionDetected)
        {
            // Update linear velocities
            int2 deltaVelA_Int2 = Float2AsInt2(deltaVelA);
            int2 deltaVelB_Int2 = Float2AsInt2(deltaVelB);

            InterlockedAdd(RBAdjustments[rbAIndex].deltaVel_Int2.x, deltaVelA_Int2.x);
            InterlockedAdd(RBAdjustments[rbAIndex].deltaVel_Int2.y, deltaVelA_Int2.y);

            InterlockedAdd(RBAdjustments[rbBIndex].deltaVel_Int2.x, deltaVelB_Int2.x);
            InterlockedAdd(RBAdjustments[rbBIndex].deltaVel_Int2.y, deltaVelB_Int2.y);

            // Update angular velocities
            int deltaRotVelA_Int = FloatAsInt(deltaRotVelA);
            int deltaRotVelB_Int = FloatAsInt(deltaRotVelB);

            InterlockedAdd(RBAdjustments[rbAIndex].deltaRotVel_Int, deltaRotVelA_Int);
            InterlockedAdd(RBAdjustments[rbBIndex].deltaRotVel_Int, deltaRotVelB_Int);
            
            // Update positions
            float2 deltaPosA = rbA.pos - posRecA;
            float2 deltaPosB = rbB.pos - posRecB;

            int2 deltaPosA_int2 = Float2AsInt2(deltaPosA);
            int2 deltaPosB_int2 = Float2AsInt2(deltaPosB);

            InterlockedAdd(RBAdjustments[rbAIndex].deltaPos_Int2.x, deltaPosA_int2.x);
            InterlockedAdd(RBAdjustments[rbAIndex].deltaPos_Int2.y, deltaPosA_int2.y);

            InterlockedAdd(RBAdjustments[rbBIndex].deltaPos_Int2.x, deltaPosB_int2.x);
            InterlockedAdd(RBAdjustments[rbBIndex].deltaPos_Int2.y, deltaPosB_int2.y);
        }
    }
}

[numthreads(TN_RBS2,1,1)]
void AdjustRBDatas(uint3 id : SV_DispatchThreadID)
{
    if (id.x >= NumRigidBodies) return;
    uint rbIndex = id.x;

    RBAdjustment rbAdjustment = RBAdjustments[rbIndex];
    RBAdjustments[rbIndex] = InitRBAdjustment();

    RigidBodies[rbIndex].pos += Int2ToFloat2(rbAdjustment.deltaPos_Int2);
    RigidBodies[rbIndex].vel_AsInt2 += rbAdjustment.deltaVel_Int2;
    RigidBodies[rbIndex].rotVel_AsInt += rbAdjustment.deltaRotVel_Int;
}

void ResolveCollisionRB_P(inout PData pData, float pMass, RigidBody rb, out float deltaRotVel, out float2 deltaCenterVel)
{
    // Initialize output parameters
    deltaRotVel = 0;
    deltaCenterVel = 0;

    // Get the hit information
    RBHitInfo rbHitInfo = RayRBDstHitInfo(pData.pos, rb);

    // Collision point on the rigid body
    float2 collisionPoint = rbHitInfo.hitPoint;
    float2 collisionNormal = float2(rbHitInfo.lineVec.y, -rbHitInfo.lineVec.x);

    // Relative velocity between the particle and the rigid body
    float2 dstToCollisionPoint = collisionPoint - rb.pos;
    float2 rotVelAtCollisionPoint = float2(-dstToCollisionPoint.y, dstToCollisionPoint.x) * IntToFloat(rb.rotVel_AsInt);
    float2 rbVel = Int2ToFloat2(rb.vel_AsInt2) + rotVelAtCollisionPoint;
    float2 relVel = pData.vel - rbVel;

    // Check if the particle is moving towards the rigid body
    float relVelAlongNormal = dot(relVel, collisionNormal);
    if (relVelAlongNormal >= 0.0) return;

    // Reflect the relative velocity across the collision normal with elasticity
    float2 mirrorRelVel = relVel - (1.0 + rb.elasticity) * relVelAlongNormal * collisionNormal;
    float2 newPVel = mirrorRelVel + rbVel;
    float2 oldPVel = pData.vel;
    pData.vel = newPVel;

    // Adjust particle's position to prevent penetration
    float penetrationDepth = dot(pData.pos - collisionPoint, collisionNormal);
    if (penetrationDepth < 0.0) pData.pos -= penetrationDepth * collisionNormal - rotVelAtCollisionPoint * DeltaTime;

    // Return if the rigid body is flagged as stationary
    bool canMove = rb.mass > 0;
    bool canRotate = rb.inertia > 0;
    if (!canMove && !canRotate) return;

    // Impulse
    float2 pImpulse = pMass * (newPVel - oldPVel);
    float2 rbImpulse = -pImpulse;

    // Vector from the rigid body's center of mass to the collision point
    float2 dst = collisionPoint - rb.pos;

    // Calculate the torque (scalar in 2D)
    float torque = cross2D(dst, rbImpulse);
    
    // Calculate delta velocities for the rigid body
    deltaCenterVel = canMove ? rbImpulse / rb.mass : 0;
    deltaRotVel = canRotate ? torque / rb.inertia : 0;
}

[numthreads(TN_RBS3,1,1)]
void SimulateRB_P(uint3 id : SV_DispatchThreadID)
{
    if (id.x >= NumParticles) return;

    uint pIndex = SpatialLookup[id.x].x;
    PData pData = PDatas[pIndex];
    PType pType = PTypes[Extract_PType(pData.lastChunkKey_PType_POrder)];
    float pMass = pType.mass;

    for (int rbIndex = 0; rbIndex < (int)NumRigidBodies; rbIndex++)
    {
        RigidBody rb = RigidBodies[rbIndex];

        // Check P_RB collision
        if (dot2(rb.pos - pData.pos) <= rb.maxRadiusSqr)
        {
            bool isInside = IsPointInsideRB(pData.pos, rb);

            if (isInside)
            {
                float deltaRotVel;
                float2 deltaCenterVel;
                ResolveCollisionRB_P(pData, pMass, rb, deltaRotVel, deltaCenterVel);

                // Atomically accumulate impulses to avoid race conditions
                if (deltaCenterVel.x != 0 && deltaCenterVel.y != 0)
                {
                    int2 deltaCenterVel_Int2 = Float2AsInt2(deltaCenterVel);
                    if (deltaCenterVel.x != 0) InterlockedAdd(RigidBodies[rbIndex].vel_AsInt2.x, deltaCenterVel_Int2.x);
                    if (deltaCenterVel.y != 0) InterlockedAdd(RigidBodies[rbIndex].vel_AsInt2.y, deltaCenterVel_Int2.y);
                }
                if (deltaRotVel != 0)
                {
                    int deltaRotVel_Int = FloatAsInt(deltaRotVel);
                    InterlockedAdd(RigidBodies[rbIndex].rotVel_AsInt, deltaRotVel_Int);
                }
            }
        }
    }

    PDatas[pIndex] = pData;
}

bool IsNearBoundary(float2 pos, float maxRadiusDstSqr)
{
    float maxRadiusDst = sqrt(maxRadiusDstSqr);

    // Check if the rigid body is near any boundary
    return pos.x - maxRadiusDst < RigidBodyPadding  // Near left boundary
        || pos.x + maxRadiusDst > BoundaryDims.x - RigidBodyPadding  // Near right boundary
        || pos.y - maxRadiusDst < RigidBodyPadding  // Near bottom boundary
        || pos.y + maxRadiusDst > BoundaryDims.y - RigidBodyPadding;  // Near top boundary
}

void GetRBBounds(RigidBody rb, inout float2 boundsMin, inout float2 boundsMax, inout float2 minXVec, inout float2 maxXVec, inout float2 minYVec, inout float2 maxYVec)
{
    uint startIndex = rb.startIndex;
    uint endIndex = rb.endIndex;
    for (uint vecIndex = startIndex; vecIndex < endIndex; vecIndex++)
    {
        float2 worldVec = RBVectors[vecIndex].pos + rb.pos;

        boundsMin = min(boundsMin, worldVec);
        boundsMax = max(boundsMax, worldVec);

        if (worldVec.x < minXVec.x) minXVec = worldVec;
        if (worldVec.x > maxXVec.x) maxXVec = worldVec;
        if (worldVec.y < minYVec.y) minYVec = worldVec;
        if (worldVec.y > maxYVec.y) maxYVec = worldVec;
    }
}

float2 InteractionForce(RigidBody rb)
{
    if (!LMousePressed && !RMousePressed) return 0;
    int dir = 0;
    if (LMousePressed) dir = -1;
    else if (RMousePressed) dir = 1;

    float2 dst = rb.pos - MousePos;

    float absDst = length(dst);

    if (absDst > RB_MaxInteractionRadius) return 0;

    float absInteractionGradient = InteractionInfluence_optimised(absDst, RB_MaxInteractionRadius);

    float2 interactionGradient = normalize(dst) * absInteractionGradient;
    float2 interactionForce = interactionGradient * RB_InteractionAttractionPower * dir;

    return interactionForce;
}

[numthreads(TN_RBS3,1,1)]
void SimulateRBSprings(uint3 id : SV_DispatchThreadID)
{
    if (id.x >= NumRigidBodies) return;
    uint i = id.x;

    RigidBody rbA = RigidBodies[i];

    // Check if the rigid body is linked to another rigid body
    bool isLinked = rbA.linkedRBIndex != -1 && rbA.linkedRBIndex != (int)i;
    if (!isLinked) return;

    // Get the linked rigid body
    RigidBody rbB = RigidBodies[rbA.linkedRBIndex];

    // Calculate the link positions in world space
    float2 linkPosA = rotate2D(rbA.localLinkPosThisRB, rbA.totRot);
    float2 linkPosB = rotate2D(rbA.localLinkPosOtherRB, rbB.totRot);

    float2 worldLinkPosA = rbA.pos + linkPosA;
    float2 worldLinkPosB = rbB.pos + linkPosB;

    // Get spring properties
    float stiffness = rbA.springStiffness;
    float springRestLength = rbA.springRestLength;
    float damping = rbA.damping;

    // Initialize delta velocities and rotations
    float2 deltaVelA = 0;
    float deltaRotVelA = 0;
    float2 deltaVelB = 0;
    float deltaRotVelB = 0;

    // Compute inverse masses and inertias
    float invMassA = (rbA.mass > 0) ? 1.0 / rbA.mass : 0;
    float invMassB = (rbB.mass > 0) ? 1.0 / rbB.mass : 0;
    float invInertiaA = (rbA.inertia > 0) ? 1.0 / rbA.inertia : 0;
    float invInertiaB = (rbB.inertia > 0) ? 1.0 / rbB.inertia : 0;

    bool rigidConstraint = stiffness == 0.0;
    if (rigidConstraint)
    {
        // **Rigid Constraint Handling**

        // Compute the positional error
        float2 constraintError = worldLinkPosB - worldLinkPosA;

        // Compute total inverse mass
        float totalInvMass = invMassA + invMassB;

        // Avoid division by zero
        if (totalInvMass == 0) return;

        // Positional correction to enforce the constraint
        float2 correction = constraintError / totalInvMass;

        // Apply corrections proportionally based on inverse masses
        float2 correctionA = correction * invMassA;
        float2 correctionB = -correction * invMassB;

        // Update positions (accumulate corrections)
        rbA.pos += correctionA;
        rbB.pos += correctionB;

        // Since we're modifying positions directly, we need to record the positional changes
        float2 deltaPosA = correctionA;
        float2 deltaPosB = correctionB;

        // Record the changes in RBAdjustments
        int2 deltaPosA_Int2 = Float2AsInt2(deltaPosA);
        int2 deltaPosB_Int2 = Float2AsInt2(deltaPosB);

        InterlockedAdd(RBAdjustments[i].deltaPos_Int2.x, deltaPosA_Int2.x);
        InterlockedAdd(RBAdjustments[i].deltaPos_Int2.y, deltaPosA_Int2.y);

        InterlockedAdd(RBAdjustments[rbA.linkedRBIndex].deltaPos_Int2.x, deltaPosB_Int2.x);
        InterlockedAdd(RBAdjustments[rbA.linkedRBIndex].deltaPos_Int2.y, deltaPosB_Int2.y);

        // Compute velocities at the link points, including rotational velocities
        float2 velAtLinkA = Int2ToFloat2(rbA.vel_AsInt2) + crossZ(IntToFloat(rbA.rotVel_AsInt), linkPosA);
        float2 velAtLinkB = Int2ToFloat2(rbB.vel_AsInt2) + crossZ(IntToFloat(rbB.rotVel_AsInt), linkPosB);

        // Compute relative velocity
        float2 relVel = velAtLinkA - velAtLinkB;

        // Compute impulse to correct velocities
        float2 direction = normalize(constraintError);
        float relVelAlongConstraint = dot(relVel, direction);

        // Compute effective mass along the constraint direction
        float rACrossN = cross2D(linkPosA, direction);
        float rBCrossN = cross2D(linkPosB, direction);
        float denom = totalInvMass + (rACrossN * rACrossN) * invInertiaA + (rBCrossN * rBCrossN) * invInertiaB;

        // Avoid division by zero
        if (denom == 0) return;

        // Compute impulse scalar
        float j = -relVelAlongConstraint / denom;

        // Compute impulse vector
        float2 impulse = j * direction;

        // Apply impulses to velocities
        if (invMassA > 0) deltaVelA += impulse * invMassA;
        if (invMassB > 0) deltaVelB -= impulse * invMassB;

        // Apply impulses to angular velocities
        if (invInertiaB > 0) deltaRotVelB -= cross2D(linkPosB, impulse) * invInertiaB;
    }
    else
    {
        // **Spring Constraint Handling**

        // Compute the vector between the link points
        float2 r = worldLinkPosA - worldLinkPosB;
        float currentLength = length(r);

        // Avoid division by zero
        if (currentLength == 0.0) return;

        float2 direction = r / currentLength;

        // Compute displacement from rest length
        float displacement = currentLength - springRestLength;

        // Compute spring force (Hooke's Law)
        float springForceMagnitude = -stiffness * displacement;

        // Compute velocities at the link points, including rotational velocities
        float2 velAtLinkA = Int2ToFloat2(rbA.vel_AsInt2) + crossZ(IntToFloat(rbA.rotVel_AsInt), linkPosA);
        float2 velAtLinkB = Int2ToFloat2(rbB.vel_AsInt2) + crossZ(IntToFloat(rbB.rotVel_AsInt), linkPosB);

        // Compute relative velocity along the spring direction
        float2 relVel = velAtLinkA - velAtLinkB;
        float relVelAlongSpring = dot(relVel, direction);

        // Compute damping force
        float dampingForceMagnitude = -damping * relVelAlongSpring;

        // Compute total force magnitude
        float totalForceMagnitude = springForceMagnitude + dampingForceMagnitude;

        // Compute total force vector
        float2 force = totalForceMagnitude * direction;

        // Apply forces to rbA and rbB
        if (invMassA > 0) deltaVelA += force * invMassA * DeltaTime;
        if (invMassB > 0) deltaVelB += (-force) * invMassB * DeltaTime;

        // Compute torques
        if (invInertiaA > 0) deltaRotVelA += cross2D(linkPosA, force) * invInertiaA * DeltaTime;
        if (invInertiaB > 0) deltaRotVelB += cross2D(linkPosB, -force) * invInertiaB * DeltaTime;
    }

    // Record the velocity and angular velocity changes in RBAdjustments
    int2 deltaVelA_Int2 = Float2AsInt2(deltaVelA);
    int2 deltaVelB_Int2 = Float2AsInt2(deltaVelB);

    InterlockedAdd(RBAdjustments[i].deltaVel_Int2.x, deltaVelA_Int2.x);
    InterlockedAdd(RBAdjustments[i].deltaVel_Int2.y, deltaVelA_Int2.y);

    InterlockedAdd(RBAdjustments[rbA.linkedRBIndex].deltaVel_Int2.x, deltaVelB_Int2.x);
    InterlockedAdd(RBAdjustments[rbA.linkedRBIndex].deltaVel_Int2.y, deltaVelB_Int2.y);

    int deltaRotVelA_Int = FloatAsInt(deltaRotVelA);
    int deltaRotVelB_Int = FloatAsInt(deltaRotVelB);

    InterlockedAdd(RBAdjustments[i].deltaRotVel_Int, deltaRotVelA_Int);
    InterlockedAdd(RBAdjustments[rbA.linkedRBIndex].deltaRotVel_Int, deltaRotVelB_Int);
}


void ResolveCollisionRB_Boundary(inout RigidBody rb, float2 collisionPoint, float2 normal)
{
    float2 r = collisionPoint - rb.pos;

    // Compute the velocity at the collision point, including rotational velocity
    float2 rbRotVelAtCollisionPoint = crossZ(IntToFloat(rb.rotVel_AsInt), r);
    float2 rbVel = Int2ToFloat2(rb.vel_AsInt2) + rbRotVelAtCollisionPoint;

    // Relative velocity (since the boundary is stationary, the relative velocity is just rbVel)
    float2 relVel = rbVel;

    // Relative velocity along the normal
    float relVelAlongNormal = dot(relVel, normal);

    // Proceed only if the body is moving towards the boundary
    if (relVelAlongNormal >= 0.0) return;

    // Compute inverse mass and inverse inertia
    float invMass = (rb.mass > 0) ? 1.0 / rb.mass : 0;
    float invInertia = (rb.inertia > 0) ? 1.0 / rb.inertia : 0;

    // Compute impulse scalar
    float rCrossN = cross2D(r, normal);

    float denom = invMass + (rCrossN * rCrossN) * invInertia;

    // Avoid division by zero
    if (denom == 0) return;

    float j = -(1 + rb.elasticity) * relVelAlongNormal / denom;

    // Compute impulse vector
    float2 impulse = j * normal;

    // Update linear velocity
    rb.vel_AsInt2 += Float2AsInt2(impulse * invMass);

    // Update angular velocity
    float deltaRotVel = cross2D(r, impulse) * invInertia;
    rb.rotVel_AsInt += FloatAsInt(deltaRotVel);

    // Positional correction to prevent sinking
    float penetrationDepth = -dot(collisionPoint - (rb.pos + r), normal);

    float epsilonCorrection = 0.3; // Small additional correction to prevent slow "sinking" through the borders
    float2 correction = (max(penetrationDepth, -epsilonCorrection) + epsilonCorrection) * normal;
    rb.pos += correction;
}


[numthreads(TN_RBS2,1,1)]
void UpdateRigidBodies(uint3 id : SV_DispatchThreadID)
{
    if (id.x >= NumRigidBodies) return;
    uint i = id.x;

    RigidBody rb = RigidBodies[i];

    // Update accumulated rotation
    rb.totRot += IntToFloat(rb.rotVel_AsInt) * DeltaTime;

    bool canMove = rb.mass > 0;
    if (canMove)
    {
        // Make sure rigid body is inside simulation bounds
        if (IsNearBoundary(rb.pos, rb.maxRadiusSqr))
        {
            float2 boundsMin = float2(1.#INF, 1.#INF);
            float2 boundsMax = float2(-1.#INF, -1.#INF);
            float2 minXVec = float2(1.#INF, 0);
            float2 maxXVec = float2(-1.#INF, 0);
            float2 minYVec = float2(0, 1.#INF);
            float2 maxYVec = float2(0, -1.#INF);
            GetRBBounds(rb, boundsMin, boundsMax, minXVec, maxXVec, minYVec, maxYVec);

            // Left boundary collision
            if (boundsMin.x < RigidBodyPadding)
            {
                float2 collisionNormal = float2(1, 0); // right
                float2 collisionPoint = minXVec;
                ResolveCollisionRB_Boundary(rb, collisionPoint, collisionNormal);
            }

            // Right boundary collision
            if (boundsMax.x > BoundaryDims.x - RigidBodyPadding)
            {
                float2 collisionNormal = float2(-1, 0); // left
                float2 collisionPoint = maxXVec;
                ResolveCollisionRB_Boundary(rb, collisionPoint, collisionNormal);
            }

            // Bottom boundary collision
            if (boundsMin.y < RigidBodyPadding)
            {
                float2 collisionNormal = float2(0, 1); // up
                float2 collisionPoint = minYVec;
                ResolveCollisionRB_Boundary(rb, collisionPoint, collisionNormal);
            }

            // Top boundary collision
            if (boundsMax.y > BoundaryDims.y - RigidBodyPadding)
            {
                float2 collisionNormal = float2(0, -1); // down
                float2 collisionPoint = maxYVec;
                ResolveCollisionRB_Boundary(rb, collisionPoint, collisionNormal);
            }
        }

        // Update position
        rb.pos += Int2ToFloat2(rb.vel_AsInt2) * DeltaTime;

        // Forces
        float2 totForce = float2(0, rb.gravity) + InteractionForce(rb);
        rb.vel_AsInt2 -= Float2AsInt2(totForce * DeltaTime);

        // Damping
        float Damping = 0.1;
        rb.vel_AsInt2 = Float2AsInt2(Int2ToFloat2(rb.vel_AsInt2) * (1 - Damping * DeltaTime));
    }

    RigidBodies[i] = rb;
}