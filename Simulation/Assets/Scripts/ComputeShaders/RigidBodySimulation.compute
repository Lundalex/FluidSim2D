#pragma kernel SimulateRB_RB // 0
#pragma kernel SimulateRB_P // 1
#pragma kernel UpdateRBVertices // 2

#include "DataTypes.hlsl"
#include "Constants.hlsl"
#include "MathResources.hlsl"
#include "CompositionResources.hlsl"

const uint2 BoundaryDims;
const float RigidBodyPadding;

const uint NumRigidBodies;
const uint NumVectors;
const uint NumParticles;

const float2 MousePos;
const bool RMousePressed;
const bool LMousePressed;
const float RB_MaxInteractionRadius;
const float RB_InteractionAttractionPower;

// Per-timestep-set constants
const float DeltaTime;

// Particles - Buffers
StructuredBuffer<int2> SpatialLookup; // [ParticlesNum](particleIndex, ChunkKey)
StructuredBuffer<PType> PTypes;
RWStructuredBuffer<PData> PDatas;

RWStructuredBuffer<RigidBody> RigidBodies;
RWStructuredBuffer<RBVector> RBVectors;

bool IsNearBoundary(float2 pos, float maxRadiusDstSqr)
{
    float maxRadiusDst = sqrt(maxRadiusDstSqr);

    // Check if the rigid body is near any boundary
    return pos.x - maxRadiusDst < RigidBodyPadding  // Near left boundary
        || pos.x + maxRadiusDst > BoundaryDims.x - RigidBodyPadding  // Near right boundary
        || pos.y - maxRadiusDst < RigidBodyPadding  // Near bottom boundary
        || pos.y + maxRadiusDst > BoundaryDims.y - RigidBodyPadding;  // Near top boundary
}

void GetRBBounds(RigidBody rb, inout float2 boundsMin, inout float2 boundsMax, inout float2 minXVec, inout float2 maxXVec, inout float2 minYVec, inout float2 maxYVec)
{
    uint startIndex = rb.startIndex;
    uint endIndex = rb.endIndex;
    for (uint vecIndex = startIndex; vecIndex < endIndex; vecIndex++)
    {
        float2 worldVec = RBVectors[vecIndex].pos + rb.pos;

        boundsMin = min(boundsMin, worldVec);
        boundsMax = max(boundsMax, worldVec);

        if (worldVec.x < minXVec.x) minXVec = worldVec;
        if (worldVec.x > maxXVec.x) maxXVec = worldVec;
        if (worldVec.y < minYVec.y) minYVec = worldVec;
        if (worldVec.y > maxYVec.y) maxYVec = worldVec;
    }
}

[numthreads(TN_RBS1,1,1)]
void UpdateRBVertices(uint3 id : SV_DispatchThreadID)
{
    if (id.x >= NumVectors) return;
    uint i = id.x;

    RBVector rbVector = RBVectors[i];

    float deltaRot = IntToFloat(RigidBodies[rbVector.parentIndex].rotVel_AsInt) * DeltaTime;

    RBVectors[i].pos = rotate(rbVector.pos, deltaRot);
}

float2 InteractionForce(RigidBody rb)
{
    if (!LMousePressed && !RMousePressed) return 0;
    int dir = 0;
    if (LMousePressed) {dir = -1;}
    else if (RMousePressed) {dir = 1;}

    float2 dst = rb.pos - MousePos;

    float absDst = length(dst);

    if (absDst > RB_MaxInteractionRadius) return 0;

    float absInteractionGradient = InteractionInfluence_optimised(absDst, RB_MaxInteractionRadius);

    float2 interactionGradient = normalize(dst) * absInteractionGradient;
    float2 interactionForce = interactionGradient * RB_InteractionAttractionPower * dir;

    return interactionForce;
}

[numthreads(TN_RBS2,1,1)]
void SimulateRB_RB(uint3 id : SV_DispatchThreadID)
{
    if (id.x >= NumRigidBodies) return;
    uint i = id.x;

    RigidBody rb = RigidBodies[i];

    // Forces
    float2 totForce = float2(0, rb.gravity) + InteractionForce(rb);
    rb.vel_AsInt -= Float2AsInt2(totForce * DeltaTime);

    // Update position & rotation
    rb.pos += Int2ToFloat2(rb.vel_AsInt) * DeltaTime;

    float bounciness = 0.5;
    float horisontalFriction = 0.2;

    // Make sure rigid body is inside simulation bounds
    if (IsNearBoundary(rb.pos, rb.maxRadiusSqr))
    {
        float2 boundsMin = float2(1.#INF, 1.#INF);
        float2 boundsMax = float2(-1.#INF, -1.#INF);
        float2 minXVec = 1.#INF;
        float2 minYVec = 1.#INF;
        float2 maxXVec = -1.#INF;
        float2 maxYVec = -1.#INF;
        GetRBBounds(rb, boundsMin, boundsMax, minXVec, minYVec, maxXVec, maxYVec);

        // X-axis collision
        if (boundsMin.x < RigidBodyPadding)
        {
            rb.pos.x += RigidBodyPadding - boundsMin.x;
            rb.vel_AsInt.x = FloatAsInt(IntToFloat(-rb.vel_AsInt.x) * bounciness);
            rb.vel_AsInt.y = FloatAsInt(IntToFloat(rb.vel_AsInt.y) * (1 - horisontalFriction));
        }
        else if (boundsMax.x > BoundaryDims.x - RigidBodyPadding)
        {
            rb.pos.x -= boundsMax.x - (BoundaryDims.x - RigidBodyPadding);
            rb.vel_AsInt.x = FloatAsInt(IntToFloat(-rb.vel_AsInt.x) * bounciness);
            rb.vel_AsInt.y = FloatAsInt(IntToFloat(rb.vel_AsInt.y) * (1 - horisontalFriction));
        }

        // Y-axis collision
        if (boundsMin.y < RigidBodyPadding)
        {
            rb.pos.y += RigidBodyPadding - boundsMin.y;
            rb.vel_AsInt.y = FloatAsInt(IntToFloat(-rb.vel_AsInt.y) * bounciness);
            rb.vel_AsInt.x = FloatAsInt(IntToFloat(rb.vel_AsInt.x) * (1 - horisontalFriction));
        }
        else if (boundsMax.y > BoundaryDims.y - RigidBodyPadding)
        {
            rb.pos.y -= boundsMax.y - (BoundaryDims.y - RigidBodyPadding);
            rb.vel_AsInt.y = FloatAsInt(IntToFloat(-rb.vel_AsInt.y) * bounciness);
            rb.vel_AsInt.x = FloatAsInt(IntToFloat(rb.vel_AsInt.x) * (1 - horisontalFriction));
        }
    }

    RigidBodies[i] = rb;
}

void AddImpulseData(inout ImpulseData a, ImpulseData b, int rbIndex)
{
    if (a.rbIndex == rbIndex)
    {
        a.centerImpulse += b.centerImpulse;
        a.rotImpulse += b.rotImpulse;
    }
    else
    {
        a.centerImpulse = b.centerImpulse;
        a.rotImpulse = b.rotImpulse;
        a.rbIndex = rbIndex;
    }
}

bool RayRBIntersect(float2 pPos, RigidBody rb)
{
    // Keep the last vector stored to avoid unnecessary data fetches
    RBVector lastVec = RBVectors[rb.startIndex];
    float2 rayEnd = float2(1.#INF, pPos.y);

    uint intersections = 0;
    uint startIndex = rb.startIndex;
    uint endIndex = rb.endIndex;
    for (uint vecIndex = startIndex + 1; vecIndex <= endIndex; vecIndex++)
    {
        RBVector newVec = RBVectors[wrapUint(vecIndex, startIndex, endIndex)];

        bool intersects = CheckLinesIntersect(pPos, rayEnd, lastVec.pos + rb.pos, newVec.pos + rb.pos);

        if (intersects) intersections++;

        lastVec = newVec;
    }

    bool isInside = intersections % 2 == 1; // intersections % 2 == 1;

    return isInside;
}

RBHitInfo RayRBIntersectHitInfo(float2 pPos, float2 pDir, RigidBody rb)
{
    // Keep the last vector stored to avoid redundant data fetches
    RBVector lastVec = RBVectors[rb.startIndex];
    RBHitInfo rbHitInfo = InitRBHitInfo();

    float2 rayStart = pPos - pDir * LARGE_FLOAT;
    float2 rayEnd = pPos + pDir * LARGE_FLOAT;

    float minDstSqr = 1.#INF;
    uint startIndex = rb.startIndex;
    uint endIndex = rb.endIndex;
    for (uint vecIndex = startIndex + 1; vecIndex <= endIndex; vecIndex++)
    {
        RBVector newVec = RBVectors[wrapUint(vecIndex, startIndex, endIndex)];

        bool intersects = CheckLinesIntersect(rayStart, rayEnd, lastVec.pos + rb.pos, newVec.pos + rb.pos);

        if (intersects)
        {
            float2 hitPoint = LineIntersectionPoint(rayStart, rayEnd, lastVec.pos + rb.pos, newVec.pos + rb.pos);
            if (hitPoint.x != 1.#INF && hitPoint.y != 1.#INF)
            {
                float dstSqr = dot2(pPos - hitPoint);
                if (dstSqr < minDstSqr)
                {
                    minDstSqr = dstSqr;
                    rbHitInfo.hitPoint = hitPoint;
                    rbHitInfo.lineVec = newVec.pos - lastVec.pos;
                }
            }
        }

        lastVec = newVec;
    }

    rbHitInfo.dst = minDstSqr == 1.#INF ? 1.#INF : sqrt(minDstSqr);
    rbHitInfo.lineVec = normalize(rbHitInfo.lineVec);

    return rbHitInfo;
}

RBHitInfo RayRBDstHitInfo(float2 pPos, RigidBody rb)
{
    // Keep the last vector stored to avoid redundant data fetches
    RBVector lastVec = RBVectors[rb.startIndex];
    RBHitInfo rbHitInfo = InitRBHitInfo();

    float minDstSqr = 1.#INF;
    uint startIndex = rb.startIndex;
    uint endIndex = rb.endIndex;
    for (uint vecIndex = startIndex + 1; vecIndex <= endIndex; vecIndex++)
    {
        RBVector newVec = RBVectors[wrapUint(vecIndex, startIndex, endIndex)];

        float2 dst = DstToLineSegment(lastVec.pos + rb.pos, newVec.pos + rb.pos, pPos);

        float dstSqr = dot2(dst);
        if (dstSqr < minDstSqr)
        {
            minDstSqr = dstSqr;
            rbHitInfo.hitPoint = pPos + dst;
            rbHitInfo.lineVec = newVec.pos - lastVec.pos;
        }

        lastVec = newVec;
    }

    rbHitInfo.dst = minDstSqr == 1.#INF ? 1.#INF : sqrt(minDstSqr);
    rbHitInfo.lineVec = normalize(rbHitInfo.lineVec);

    return rbHitInfo;
}

void SetPosWithSafeGuards(inout float2 pos, float2 newPos, float2 vec)
{
    float diffThreshold = 1.0;

    float sqrDst = dot2(newPos - pos);
    if (sqrDst < diffThreshold)
    {
        float2 epsilonOffset = vec * 0.1;
        pos = newPos + epsilonOffset;
    }
}

// if particles begin to "teleport", use SetPosWithSafeGuards(pData.pos, collisionPoint, collisionNormal)
float3 ResolveCollision(inout PData pData, float pMass, RigidBody rb)
{
    // Get the hit information
    RBHitInfo rbHitInfo = RayRBDstHitInfo(pData.pos, rb);

    // Collision point on the rigid body
    float2 collisionPoint = rbHitInfo.hitPoint;
    float2 collisionNormal = float2(rbHitInfo.lineVec.y, -rbHitInfo.lineVec.x);

    // Relative velocity between the particle and the rigid body
    float2 rotVelAtCollisionPoint = rotate(normalize(collisionPoint - rb.pos), PI / 2.0) * IntToFloat(rb.rotVel_AsInt) * length(collisionPoint - rb.pos);
    float2 rbVel = Int2ToFloat2(rb.vel_AsInt) + rotVelAtCollisionPoint;
    float2 relVel = pData.vel - rbVel;

    // Check if the particle is moving towards the rigid body
    float relVelAlongNormal = dot(relVel, collisionNormal);
    if (relVelAlongNormal >= 0.0) return 0;

    // Reflect the relative velocity across the collision normal with elasticity
    float2 mirrorRelVel = relVel - (1.0 + rb.elasticity) * relVelAlongNormal * collisionNormal;
    float2 newPVel = mirrorRelVel + rbVel;
    float2 oldPVel = pData.vel;
    pData.vel = newPVel;

    // Adjust particle's position to prevent penetration
    float penetrationDepth = dot(pData.pos - collisionPoint, collisionNormal);
    if (penetrationDepth < 0.0) pData.pos -= penetrationDepth * collisionNormal - rotVelAtCollisionPoint * DeltaTime;

    // Return 0 if the rigid body is flagged as stationary
    if (rb.mass == 0.0) return 0;

    // Calculate the impulse applied to the particle (change in momentum)
    float2 pImpulse = pMass * (newPVel - oldPVel);
    float2 rbImpulse = -pImpulse;

    // Vector from the rigid body's center of mass to the collision point
    float2 dst = collisionPoint - rb.pos;

    // Calculate the torque (scalar in 2D)
    float rotImpulse = cross2d(dst, rbImpulse);
    
    // Calculate delta velocities for the rigid body
    float2 deltaRBVel = rbImpulse / rb.mass;
    float deltaRBAngVel = rotImpulse / rb.inertia;

    return float3(deltaRBVel.x, deltaRBVel.y, deltaRBAngVel);
}

[numthreads(TN_RBS3,1,1)]
void SimulateRB_P(uint3 id : SV_DispatchThreadID)
{
    if (id.x >= NumParticles) return;

    uint pIndex = SpatialLookup[id.x].x;
    PData pData = PDatas[pIndex];
    PType pType = PTypes[Extract_PType(pData.lastChunkKey_PType_POrder)];
    float pMass = pType.mass;

    for (int rbIndex = 0; rbIndex < (int)NumRigidBodies; rbIndex++)
    {
        RigidBody rb = RigidBodies[rbIndex];

        // Check P_RB collision
        if (dot2(rb.pos - pData.pos) <= rb.maxRadiusSqr)
        {
            bool isInside = RayRBIntersect(pData.pos, rb);

            if (isInside)
            {
                float3 deltaRBVel = ResolveCollision(pData, pMass, rb);

                if (deltaRBVel.x == 1.#INF || deltaRBVel.y == 1.#INF || deltaRBVel.z == 1.#INF) continue;

                // Convert impulses to integers
                int2 deltaCenterVelInt2 = Float2AsInt2(deltaRBVel.xy);
                int deltaRotVelInt = FloatAsInt(deltaRBVel.z);

                // Atomically accumulate impulses to avoid race conditions
                InterlockedAdd(RigidBodies[rbIndex].vel_AsInt.x, deltaCenterVelInt2.x);
                InterlockedAdd(RigidBodies[rbIndex].vel_AsInt.y, deltaCenterVelInt2.y);
                InterlockedAdd(RigidBodies[rbIndex].rotVel_AsInt, deltaRotVelInt);
            }
        }
    }

    PDatas[pIndex] = pData;
}